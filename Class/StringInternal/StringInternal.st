//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "StringInternal"
	Revision           = "1.81"
	GUID               = "{2C12408A-7CCA-458A-912B-98C634EE4BD9}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\StringInternal\aString.ICO"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "handels character strings">
	<Channels>
		<Server Name="Data" WriteProtected="false">
		</Server>
		<Client Name="DataBuffer" Required="true" Internal="false" Comment="some extern storage mechanism (retentive or not)"/>
		<Client Name="SingleRealloc" Required="false" Internal="false" DefValue="1" Comment="This client is used for optimized memory handling!&#13;&#10;1..Optimized memory handling -&gt; realloc only if string grows (default)&#13;&#10;0..Normal memory handling -&gt; the needed memory is allocated"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\StringInternal\StringDefs.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek GmbH &amp; Co KG"/>
		<Dokumentation Revision="1.81" Date="2016-01-25" Company="Sigmatek GmbH &amp; Co KG" Description="Bugfix:&#13;&#10;It is now possible to write a single CHAR character with the Method WriteDataOffUni();"/>
		<Dokumentation Revision="1.80" Date="2015-09-25" Author="Fimluc" Company="Sigmatek GmbH &amp; Co KG" Description="All global functions virtual"/>
		<Dokumentation Revision="1.71" Date="2014-07-30" Author="HlaWol" Company="Sigmatek GmbH &amp; Co KG" Description="SA28794: AddTermination() returned pointer of GetData() has to be validated&#13;&#10;"/>
		<Dokumentation Revision="1.70" Date="2014-02-20" Author="spimar" Company="Sigmatek GmbH &amp; Co KG" Description="Check for valid pointer"/>
		<Dokumentation Revision="1.60" Date="2013-11-06" Author="feshar" Company="Sigmatek GmbH &amp; Co KG" Description="Set the init value. (Set a new RamEx object to length 0.)"/>
		<Dokumentation Revision="1.50" Date="2013-09-23" Author="spimar" Company="Sigmatek GmbH &amp; Co KG" Description="Check valid pointer after alloc;"/>
		<Dokumentation Revision="1.40" Date="2013-07-12" Author="spimar&#13;&#10;kolott" Company="Sigmatek" Description="Check if there is already data stored in object;&#13;&#10;ARM-Ready"/>
		<Dokumentation Revision="1.30" Date="2013-01-07" Author="spimar&#13;&#10;fesgue" Company="Sigmatek" Description="Improvement: &#13;&#10;-added comments in code;&#13;&#10;-added a check if the pointer is valid (WriteDataOffUni);&#13;&#10;Bugfix: Memory fault in WriteDataOffUni();"/>
		<Dokumentation Revision="1.20" Date="2012-11-21" Author="spimar" Company="Sigmatek" Description="Bugfix with client SingleRealloc;&#13;&#10;- The termination of the string was set on the wrong place in case of client is set to 1;&#13;&#10;- Added comments in code;"/>
		<Dokumentation Revision="1.10" Date="2012-11-05" Author="spimar" Company="Sigmatek" Description="New client (SingleRealloc) which is used for an optimized memory handling!"/>
		<Dokumentation Revision="1.7" Date="2012-09-24" Author="feshar" Company="Sigmatek" Description="String Initvalue was not set for RamEx objects with file storage."/>
		<Dokumentation Revision="1.6" Date="2012-08-02" Author="spimar" Company="Sigmatek" Description="Added a new method named WriteDataOffUni with which one it is possible, to hand over the size (Ascii or Uni), without set the identifier in front of the string!"/>
		<Dokumentation Revision="1.5" Date="2012-05-03" Author="feshar" Company="Sigmatek" Description="Changes for RamEx file storage."/>
		<Dokumentation Revision="1.4" Date="2011-09-28" Author="SpiMar" Company="Sigmatek" Description="Corrected a comment;"/>
		<Dokumentation Revision="1.3" Date="2011-09-28" Author="SpiMar" Company="Sigmatek" Description="The input and output parameters of the server write methods  are now fitted to the datatype of the server;"/>
	</RevDoku>
	<Network Name="StringInternal">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{6CBDDE57-D222-420A-BC45-D2266096244E}"
				Class      = "VirtualBaseInit"
				Position   = "(570,330)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Data" Destination="_base.Data" Vertices="(1042,210),(870,420),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using VirtualBaseInit

StringInternal : CLASS
: VirtualBaseInit
  //Servers:
  //Clients:
	DataBuffer 	: CltChCmd_MerkerEx;
	SingleRealloc 	: CltCh_DINT;
  //Variables:
		m_udCRC 	: UDINT;			//! <Variable Comment="for faster detection of changes" Name="m_udCRC"/>
		m_usSize 	: USINT;			//! <Variable Comment="size of one character" Name="m_usSize"/>
		m_udlen 	: UDINT;
  //Functions:
				//! <Function Comment=" to have a defined state after configuration&#13;&#10; calculate the CRC&#13;&#10;Die CRC wird am Anfang berechnet, um diesen Wert zu initialisieren&#13;&#10;" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment=" standard constructor of the string class&#13;&#10;Standard - Konstruktor der String - Klasse&#13;&#10;" Name="StringInternal"/>
	FUNCTION StringInternal
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment=" returns the length of the raw data (without termination-0)&#13;&#10;liefert die Länge der Strings-Rohdaten ohne Abschluß-Null&#13;&#10;" Name="GetLength"/>
	FUNCTION VIRTUAL GLOBAL GetLength
		VAR_OUTPUT
			udLen 	: UDINT;			//! <Variable Comment="number of characters" Name="GetLength.udLen"/>
		END_VAR;
				//! <Function Comment="The function extracts the given amount of bytes from a string-buffer.&#13;&#10;udAt specifies the starting position. pData is a pointer to a destination&#13;&#10;buffer, which has to be big enough to contain the extracted part.&#13;&#10;Die Funktion kopiert die angegebene Anzahl von Bytes ab dem Offset udAt&#13;&#10;aus dem String in einen zur Verfügung gestellten Ziel-Puffer. Dieser&#13;&#10;Puffer muß ausreichend groß sein, um den extrahierten Teil aufnehmen&#13;&#10;zu können.&#13;&#10;[&gt;udSize] Anzahl der Bytes, die kopiert werden sollen&#13;&#10;" Name="GetDataAt"/>
	FUNCTION VIRTUAL GLOBAL GetDataAt
		VAR_INPUT
			pData 	: ^USINT;			//! <Variable Comment="Zeigt auf die Quelldaten" Name="GetDataAt.pData"/>
			udSize 	: UDINT;			//! <Variable Comment=" number of bytes to extract" Name="GetDataAt.udSize"/>
			udAt 	: UDINT;			//! <Variable Comment="offset within the string-buffer" Name="GetDataAt.udAt"/>
		END_VAR;
				//! <Function Comment="Initialisiert den String mit konstanten Daten, z.B. aus einer Tabelle&#13;&#10;Der String wird als ASCII-String interpretiert.&#13;&#10;Initializes a string object with constant data (i.e. from a table)&#13;&#10;The string is assumed to be an ASCII-string&#13;&#10;" Name="InitFromTable"/>
	FUNCTION VIRTUAL GLOBAL InitFromTable
		VAR_INPUT
			udLen 	: UDINT;			//! <Variable Comment="Länge der Initialisierungsdaten in Bytes" Name="InitFromTable.udLen"/>
			pData 	: ^USINT;			//! <Variable Comment="pointer to source" Name="InitFromTable.pData"/>
		END_VAR;
				//! <Function Comment=" The function doesn&apos;t provide default functionality&#13;&#10; Please overwrite it for derived classes.&#13;&#10; Die Funktion stellt keine Standard-Implementierung dar. Sie muß für abgeleitete&#13;&#10; Klassen überschrieben werden.&#13;&#10;[&gt;udOff] Offset innerhalb des internen Datenpuffers, auf den die Daten kopiert werden sollen&#13;&#10;" Name="WriteDataOff"/>
	FUNCTION VIRTUAL GLOBAL WriteDataOff
		VAR_INPUT
			udLen 	: UDINT;			//! <Variable Comment=" Length of initialization data block" Name="WriteDataOff.udLen"/>
			udOff 	: UDINT;			//! <Variable Comment=" form this offset the data is read" Name="WriteDataOff.udOff"/>
			pData 	: ^USINT;
		END_VAR;
				//! <Function Comment=" The function returns a CRC of the string&apos;s data buffer&#13;&#10; This CRC is recalculated everytime the contents are changed&#13;&#10;Die Funktion liefert eine Prüfsumme über den Stringinhalt. Diese CRC&#13;&#10;wird bei jeder String-Änderung angepaßt.&#13;&#10;[&lt;udCRC]32-bit-CRC&#13;&#10;" Name="GetCRC"/>
	FUNCTION VIRTUAL GLOBAL GetCRC
		VAR_OUTPUT
			udCRC 	: UDINT;			//! <Variable Comment="32-bit-CRC" Name="GetCRC.udCRC"/>
		END_VAR;
				//! <Function Comment="Kopiert den Inhalt des übergebenen Strings in das eigene String-Objekt.&#13;&#10;Die Inhalte beider Strings sind danach ident.&#13;&#10; Copies the raw data from the passed string to the current one.&#13;&#10; The contents of the data blocks of both strings are the same&#13;&#10; afterwards.&#13;&#10;" Name="StrCpy"/>
	FUNCTION VIRTUAL GLOBAL StrCpy
		VAR_INPUT
			pSrc 	: ^StringInternal;			//! <Variable Comment="pointer to string to append" Name="StrCpy.pSrc"/>
		END_VAR;
				//! <Function Comment="The passed string is appended to the current string&#13;&#10;If the strings styles differ (ASCII/UNICODE), then the passed string&#13;&#10;will be converted to the current string&apos;s style prior to appending it.&#13;&#10;Der übergebene String wird an den eigenen String hinten angehängt.&#13;&#10;Wenn die Strings unterschiedliche Typen haben (ASCII/UNICODE), dann&#13;&#10;wird der übergebene String zuerst angepaßt, und dann erst angehängt.&#13;&#10;" Name="StrCat"/>
	FUNCTION VIRTUAL GLOBAL StrCat
		VAR_INPUT
			pSrc 	: ^StringInternal;			//! <Variable Comment="Zeiger auf den anzuhängenden String" Name="StrCat.pSrc"/>
		END_VAR;
				//! <Function Comment="Der String wird auf einen Leerstring gesetzt.&#13;&#10; the string contents of the string are set to an empty string&#13;&#10;" Name="Clear"/>
	FUNCTION VIRTUAL GLOBAL Clear;
				//! <Function Comment=" Every time the string contents are changed, this function&#13;&#10; should be called to recalculate the check sum.&#13;&#10;Diese Funktion muß nach jeder String-Änderung aufgerufen werden,&#13;&#10;um die Prüfsumme über den Stringinhalt zu aktualisieren.&#13;&#10;" Name="CalcCRC"/>
	FUNCTION CalcCRC;
				//! <Function Comment="The two strings are compared case sensitive. The function returns 0&#13;&#10;if the strings are exactly the same, otherwise it returns &lt;&gt;0.&#13;&#10;If one of the two strings is in UNICODE, then the other is converted&#13;&#10;to UNICODE, too, before the comparison.&#13;&#10;None of the strings is changed!&#13;&#10;Die beiden Strings werden mit Unterscheidung von Groß/Kleinschreibung&#13;&#10;verglichen. Die Funktion liefert 0, wenn die beiden Strings exakt&#13;&#10;gleich sind, sonst &lt;&gt;0.&#13;&#10;Wenn einer der beiden Strings UNICODE-Zeichen enthält, dann wird auch&#13;&#10;der andere String auf UNICODE transformiert, bevor der Vergleich&#13;&#10;durchgeführt wird.&#13;&#10;Keiner der beiden Strings wird dadurch verändert!&#13;&#10;" Name="StrCmp"/>
	FUNCTION VIRTUAL GLOBAL StrCmp
		VAR_INPUT
			pStr 	: ^StringInternal;			//! <Variable Comment="Zeiger auf den Zielstring" Name="StrCmp.pStr"/>
		END_VAR
		VAR_OUTPUT
			udNotEqual 	: UDINT;			//! <Variable Comment="0 .. equal, &lt;&gt; 0 .. not equal" Name="StrCmp.udNotEqual"/>
		END_VAR;
				//! <Function Comment="The two strings are compared case insensitive. The function will return 0 if the&#13;&#10;strings are the same, otherwise it returns &lt;&gt;0.&#13;&#10;Comparing &quot;Abc&quot; with &quot;Abc&quot; or &quot;Abc&quot; with &quot;ABC&quot; will result in 0,&#13;&#10;comparing &quot;PLC&quot; with &quot;SPS&quot; will result in a value different from 0&#13;&#10;Die beiden Strings werden ohne Berücksichtigung der Groß/Kleinschreibung&#13;&#10;miteinander verglichen. Die Funktion liefert für gleiche Strings 0,&#13;&#10;ansonsten einen Wert &lt;&gt; 0.&#13;&#10;Der Vergleich von &quot;Abc&quot; mit &quot;Abc&quot; oder von &quot;Abc&quot; mit &quot;ABC&quot; liefert 0,&#13;&#10;der Vergleich &quot;PLC&quot; mit &quot;SPS&quot; liefert einen Wert ungleich 0.&#13;&#10;" Name="StriCmp"/>
	FUNCTION VIRTUAL GLOBAL StriCmp
		VAR_INPUT
			pStr 	: ^StringInternal;			//! <Variable Comment="pointer to the destination string" Name="StriCmp.pStr"/>
		END_VAR
		VAR_OUTPUT
			udNotEqual 	: UDINT;			//! <Variable Comment="0 .. gleich, &lt;&gt; 0 .. ungleich" Name="StriCmp.udNotEqual"/>
		END_VAR;
				//! <Function Comment="Der linke Teil des Strings wird in den Zielstring kopiert. Wenn&#13;&#10;die angegebene Zeichenzahl größer als die Stringlänge ist, wird&#13;&#10;nur der ursprüngliche String kopiert.&#13;&#10;The left part of the string is copied to the specified string object. If udCnt exceeds&#13;&#10;the string length, only the string contents are copied&#13;&#10;" Name="Left"/>
	FUNCTION VIRTUAL GLOBAL Left
		VAR_INPUT
			udCnt 	: UDINT;			//! <Variable Comment="Anzahl der zu kopierenden Zeichen" Name="Left.udCnt"/>
			pStr 	: ^StringInternal;
		END_VAR;
				//! <Function Comment="Die Funktion kopiert die letzten udCnt Zeichen des Strings in den&#13;&#10;Zielstring. Wenn die angegebene Zeichenzahl größer als die String-&#13;&#10;länge ist, wird nur der ursprüngliche String kopiert.&#13;&#10;The function copies the specified number of characters to the destination string. If&#13;&#10;the specified number exceeds the string length, only the string contents are copied.&#13;&#10;" Name="Right"/>
	FUNCTION VIRTUAL GLOBAL Right
		VAR_INPUT
			udCnt 	: UDINT;			//! <Variable Comment="number of characters to extract" Name="Right.udCnt"/>
			pStr 	: ^StringInternal;
		END_VAR;
				//! <Function Comment="All lower case letters are converted to upper case letters. The&#13;&#10;string object itself will be changed.&#13;&#10;Alle Kleinbuchstaben werden in Großbuchstaben konvertiert. Durch diese&#13;&#10;Funktion wird der String selbst geändert.&#13;&#10;" Name="StrUpr"/>
	FUNCTION VIRTUAL GLOBAL StrUpr;
				//! <Function Comment="All characters of a UNICODE-string are converted to ASCII-characters.&#13;&#10;If a character can not be transformed to ASCII-code, it will be replaced&#13;&#10;by a SPACE-character (0x20).&#13;&#10;Die Zeichen eines UNICODE-STrings werden in ASCII-Code gewandelt. Wenn&#13;&#10;sich ein Zeichen nicht auf ASCII-Code abbilden läßt, dann wird es durch&#13;&#10;ein Leerzeichen (0x20) ersetzt.&#13;&#10;" Name="ToAscii"/>
	FUNCTION VIRTUAL GLOBAL ToAscii;
				//! <Function Comment="All characters of an ASCII-string are converted to UNICODE.&#13;&#10;Alle Zeichen eines ASCII-Strings werden auf UNICODE übersetzt.&#13;&#10;" Name="ToUniCode"/>
	FUNCTION VIRTUAL GLOBAL ToUniCode;
				//! <Function Comment="All upper case letters are converted to lower case letters. The&#13;&#10;string object itself will be changed.&#13;&#10;Alle Großbuchstaben werden in Kleinbuchstaben konvertiert. Durch diese&#13;&#10;Funktion wird der String selbst geändert.&#13;&#10;" Name="StrLwr"/>
	FUNCTION VIRTUAL GLOBAL StrLwr;
				//! <Function Comment="The function searches for the given character in its string-buffer.&#13;&#10;It returns -1 if the character was not found, otherwise the index&#13;&#10;of the 1st matching character.&#13;&#10;Die Funktion sucht im String-Puffer nach dem angegebenen Zeichen.&#13;&#10;Sie liefert -1, wenn das Zeichen nicht gefunden wurde, ansonsten&#13;&#10;den Index des ersten übereinstimmenden Zeichens.&#13;&#10;[&gt;uiChar] Zeichen, nach dem gesucht werden soll&#13;&#10;" Name="StrChr"/>
	FUNCTION VIRTUAL GLOBAL StrChr
		VAR_INPUT
			uiChar 	: UINT;			//! <Variable Comment=" character to search for" Name="StrChr.uiChar"/>
		END_VAR
		VAR_OUTPUT
			udPosition 	: UDINT;
		END_VAR;
				//! <Function Comment="Checks, if the string is terminated with a 0-character. If not, &#13;&#10;a 0-character is appended. The string length is not changed by&#13;&#10;this function.&#13;&#10;Prüft, ob ein String mit 0 abgeschlossen ist. Wenn nicht, dann&#13;&#10;wird hier ein &apos;\0&apos;-Zeichen angehängt. Die Stringlänge ändert sich dadurch &#13;&#10;nicht.&#13;&#10;" Name="AddTermination"/>
	FUNCTION AddTermination;
				//! <Function Comment="Returns the number of characters in the string.&#13;&#10;For ASCII - strings this is equal to the number of bytes, for&#13;&#10;Unicode - strings it&apos;s just the half of it.&#13;&#10;The string length does not include the terminating zero.&#13;&#10;Liefert die Anzahl der Zeichen in einem String.&#13;&#10;Bei ASCII - Strings entspricht das genau der Anzahl an Daten - Bytes,&#13;&#10;bei Unicode - Strings ist es die Hälfte davon.&#13;&#10;Die Abschluß - Null ist nicht inkludiert.&#13;&#10;" Name="StrLen"/>
	FUNCTION VIRTUAL GLOBAL StrLen
		VAR_OUTPUT
			udLen 	: UDINT;			//! <Variable Comment="Anzahl der Zeichen" Name="StrLen.udLen"/>
		END_VAR;
				//! <Function Comment="Set a character to the String at a given position&#13;&#10;Setzt ein Zeichen an einer bestimmten Position des Strings&#13;&#10;" Name="SetDataAt"/>
	FUNCTION VIRTUAL GLOBAL SetDataAt
		VAR_INPUT
			pData 	: ^UINT;
			udAt 	: UDINT;			//! <Variable Comment="Position im String an der das Zeichen gesetzt wird" Name="SetDataAt.udAt"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;returns 1 for ASCII strings and 2 for Unicode strings&#13;&#10;" Name="GetCharSize"/>
	FUNCTION VIRTUAL GLOBAL GetCharSize
		VAR_OUTPUT
			usSize 	: USINT;			//! <Variable Comment="size of one character in the string (ASCII vs. Unicode)" Name="GetCharSize.usSize"/>
		END_VAR;
				//! <Function Comment=" The function doesn&apos;t provide default functionality&#13;&#10; Please overwrite it for derived classes.&#13;&#10; Die Funktion stellt keine Standard-Implementierung dar. Sie muß für abgeleitete&#13;&#10; Klassen überschrieben werden.&#13;&#10;[&gt;udOff] Offset innerhalb des internen Datenpuffers, auf den die Daten kopiert werden sollen&#13;&#10;" Name="WriteDataOffUni"/>
	FUNCTION VIRTUAL GLOBAL WriteDataOffUni
		VAR_INPUT
			udlen 	: UDINT;			//! <Variable Comment="length of initialization data in bytes" Name="WriteDataOffUni.udlen"/>
			udOff 	: UDINT;			//! <Variable Comment=" offset where data should be copied to" Name="WriteDataOffUni.udOff"/>
			pData 	: ^UINT;			//! <Variable Comment="contains the stringdata" Name="WriteDataOffUni.pData"/>
			usSize 	: USINT;			//! <Variable Comment="hand over the size of one character!&#13;&#10;1 = ASCII, 2 = Unicode" Name="WriteDataOffUni.usSize"/>
		END_VAR;
				//! <Function Comment="[!GET_ADD_INFO]&#13;&#10; Klassenaghängige Zusatzinformation wird geliefert&#13;&#10;[!GET_ADD_INFO]&#13;&#10; returns class specific additional information&#13;&#10;" Name="Data.NewInst"/>
	FUNCTION VIRTUAL GLOBAL Data::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Data::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Data::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd MerkerEx


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB StringInternal::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_STRINGINTERNAL
1$UINT, 81$UINT, (SIZEOF(::StringInternal))$UINT, 
0$UINT, 2$UINT, 0$UINT, 
TO_UDINT(2898603620), "StringInternal", //Class
TO_UDINT(3232495061), "VirtualBaseInit", 1$UINT, 3$UINT, //Baseclass
//Servers:
//Clients:
(::StringInternal.DataBuffer.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4265790926), "DataBuffer", TO_UDINT(2225119864), "MerkerEx", 1$UINT, 21$UINT, 
(::StringInternal.SingleRealloc.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(155664527), "SingleRealloc", 
END_FUNCTION


#define USER_CNT_StringInternal 22

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_StringInternal] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION StringInternal::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= VirtualBaseInit::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= VirtualBaseInit::Data.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, VirtualBaseInit::Data.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_StringInternal;
	vmt.CmdTable.NewInstr		:= #Data::NewInst();
	vmt.CmdTable.Read		:= #Data::Read();
	vmt.CmdTable.Write		:= #Data::Write();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #GetLength();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #GetDataAt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #InitFromTable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #WriteDataOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #GetCRC();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #StrCpy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #StrCat();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #Clear();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #StrCmp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #StriCmp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #Left();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Right();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #StrUpr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #ToAscii();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #ToUniCode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #StrLwr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #StrChr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #StrLen();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #SetDataAt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #GetCharSize();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #WriteDataOffUni();

#pragma warning (default : 74)
	VirtualBaseInit::Data.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF VirtualBaseInit::Data.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= StringInternal();

END_FUNCTION

//{{LSL_IMPLEMENTATION


//*********************Inserted from .\code\String.st*********************

#include <RTOS_MemIntern.h>

 


//==============================================================
#define GetData()				DataBuffer.GetDataPtr()
#define IsAscii()				GetCharSize() = sizeof(char)
#define IsUniCode()				GetCharSize() = sizeof(UINT)
//==============================================================

(*
  String-Darstellung:
  
  Die Zeichen sind im DataBuffer gespeichert und mit einem 0-Zeichen abgeschlossen.
  Im neuen Format (UNICODE - Zeichengröße 2) ist zusätzlich in den ersten beiden 
  Bytes die Größe eines Zeichens (immer = 2) gespeichert.
  Die Länge der String-Daten (inkl. optionaler Zeichengröße und 0-Ende-Zeichen) 
  ist ebenfalls im Objekt gespeichert (m_udLength).
  Eine m_udLength von 0 muß als ASCII Leerstring interpretiert werden.
  Eine m_udLength von 2 und Zeichengröße 2 muß als UNICODE Leerstring interpretiert werden.

  Unterscheidung ASCII / UNICODE:
  Wenn im DataBuffer als erstes Byte ein 0er steht und die Länge der Daten im 
  Datenbuffer > 1 und die Zeichengröße 2 ist, dann handelt es sich um einen Unicode-String.
  Alles andere ist ASCII.
  
  Bsp.
  
    m_udLength = 0                  Leerstring in ASCII
    '\0'                            Leerstring in ASCII
    'A'  '\0'                       String "A" in ASCII
    
    '\0' '\2'                       Leerstring in UNICODE
    '\0' '\2' '\0' '\0'             Leerstring in UNICODE
    '\0' '\2' '\0' 'A'  '\0' '\0'   String "A" in UNICODE
*)

VAR_GLOBAL
	sCopy1,
	sCopy2		: ^StringInternal;
END_VAR

FUNCTION NewTempString
VAR_OUTPUT
	pObj	: ^StringInternal;
END_VAR
VAR
	pMem	: ^MerkerEx;
END_VAR

	// create the object with string functionality
	pObj	:= NewObj("StringInternal")$^StringInternal;
	IF pObj = NIL THEN
		RETURN;
	END_IF;
	// create the object with storage capability
	pMem	:= NewObj("MerkerEx")$^MerkerEx;
	IF pMem = NIL THEN
		pObj	:= NIL;
		RETURN;
	END_IF;
	// connect the 2 objects
	pObj^.DataBuffer.pCh	:= pMem$^SvrChCmd_UDINT;
	pObj^.DataBuffer.pCmd	:= pMem;

END_FUNCTION

FUNCTION  StringInternal::StringInternal
VAR_OUTPUT
	ret_code		: CONFSTATES;
END_VAR

	// create temporary helper objects
	IF _IsFirstObj(this$^VirtualBase, "StringInternal") THEN
		sCopy1	:= NewTempString();
		sCopy2	:= NewTempString();
		IF sCopy1 = NIL | sCopy2 = NIL THEN
			ret_code	:= C_OUTOF_NEAR;
			RETURN;
		END_IF;
	END_IF;
	
	ret_code	:= C_OK;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL StringInternal::GetLength
VAR_OUTPUT
	udLen		: UDINT;
END_VAR
VAR
  pa : ^usint;
  pu : ^uint;
  tmplen  : UDINT;
END_VAR

  tmplen := DataBuffer.m_udLength; // Get act. allocated size
  udLen := 0;
  pa    := GetData();

  if(pa <> NIL) & (tmplen > 0) then
    if(GetCharSize() = 1) then
      udLen := _strlen(pa);
    else
      pu := pa$^uint;
      while(pu^ <> 0) do
        udLen += 2;
        pu    += 2;
      end_while;
    end_if;
  end_if;

END_FUNCTION
//[#ENGLISH]
//The function extracts the given amount of bytes from a string-buffer.
//udAt specifies the starting position. pData is a pointer to a destination
//buffer, which has to be big enough to contain the extracted part.
//[>pData]	pointer to the destination buffer
//[>udSize]	number of bytes to extract
//[>udAt]	offset within the string-buffer
//[#DEUTSCH]
//Die Funktion kopiert die angegebene Anzahl von Bytes ab dem Offset udAt
//aus dem String in einen zur Verfügung gestellten Ziel-Puffer. Dieser
//Puffer muß ausreichend groß sein, um den extrahierten Teil aufnehmen
//zu können.
//[>pData]	Zeiger auf den Ziel-Puffer
//[>udSize]	Anzahl der Bytes, die kopiert werden sollen
//[>udAt]	Offset im String, ab dem kopiert werden soll
FUNCTION VIRTUAL GLOBAL StringInternal::GetDataAt
VAR_INPUT
	pData		: ^USINT;
	udSize		: UDINT;
	udAt		: UDINT;
END_VAR

	DataBuffer.GetDataAt(pData, udSize, udAt);

END_FUNCTION //VIRTUAL GLOBAL StringInternal::GetDataAt
//[#ENGLISH]
// The function doesn't provide default functionality
// Please overwrite it for derived classes.
//[>udLen]	data length to be copied
//[>udOff]	offset where data should be copied to
//[>pData]	pointer to new data
//[#DEUTSCH]
// Die Funktion stellt keine Standard-Implementierung dar. Sie muß für abgeleitete
// Klassen überschrieben werden.
//[>udLen] Länge des übergebenen Datenpuffers
//[>udOff] Offset innerhalb des internen Datenpuffers, auf den die Daten kopiert werden sollen
//[>pData] Zeiger auf den neuen Datenblock
FUNCTION VIRTUAL GLOBAL StringInternal::WriteDataOff
VAR_INPUT
  udLen 	: UDINT;
  udOff 	: UDINT;
  pData 	: ^USINT;
END_VAR
VAR
  tmplen  : UDINT;
  tmpretcode  : ConfStates;
END_VAR

  tmpretcode := C_OK;

	// check if the string representation is given
	IF udOff = 0 THEN
		IF pData & udLen >= 2 & pData$^UINT^ = 16#0200 THEN
			ToUnicode();
		ELSE
			IF pData & udLen >= 2 & pData$^UINT^ = 16#0100 THEN
				// pr, 13.12.2004 Workaround:
				// Wenn jemand versucht, einen ASCII String mit einem Zeichengröße-WORD 
				// zu initialisieren, dann wird das Zeichengröße-WORD hier entfernt.
				// Ein ASCII String darf nämlich nur ohne Zeichengröße abgespeichert werden !
				// Leider gibt es schon Code, der einen ASCII String mit einem Zeichengröße-WORD 
				// initialisiert, daher ist dieser Workaround nötig.
				pData += 2;
				udLen -= 2;
			END_IF;
			ToAscii();
		END_IF;
	END_IF;

  tmplen := udOff+udLen;

	// set the string to the new length
  IF (SingleRealloc = 0) THEN //  If client is not set the function works like it did before rev. >= 1.8
	  tmpretcode := DataBuffer.SetSize(tmplen);

  ELSE
    IF (tmplen > DataBuffer.m_udLength) THEN
      tmpretcode := DataBuffer.SetSize(tmplen);

    END_IF;
  END_IF;

  if (tmpretcode = C_OK) then
    DataBuffer.SetDataAt(pData, udLen, udOff);

    m_udlen := tmplen;  //  set the length which is used in next method
    AddTermination();
    CalcCRC();
  end_if;

END_FUNCTION //VIRTUAL GLOBAL StringInternal::WriteDataOff
//[#DEUTSCH]
//Initialisiert den String mit konstanten Daten, z.B. aus einer Tabelle
//Der String wird als ASCII-String interpretiert.
//[>udLen]Länge der Initialisierungsdaten in Bytes
//[>pData]Zeiger auf die Initialisierungsdaten
//[#ENGLISH]
//Initializes a string object with constant data (i.e. from a table)
//The string is assumed to be an ASCII-string
//[>udLen]length of initialization data in bytes
//[>pData]pointer to initialization data
FUNCTION VIRTUAL GLOBAL StringInternal::InitFromTable
VAR_INPUT
	udLen		: UDINT;
	pData		: ^USINT;
END_VAR


  IF DataBuffer.GetDataPtr () = 0 THEN
    IF pData & udLen >= 2 & pData$^UINT^ = 16#0100 THEN
      // pr, 13.12.2004 Workaround:
      // Wenn jemand versucht, einen ASCII String mit einem Zeichengröße-WORD 
      // zu initialisieren, dann wird das Zeichengröße-WORD hier entfernt.
      // Ein ASCII String darf nämlich nur ohne Zeichengröße abgespeichert werden !
      // Leider gibt es schon Code, der einen ASCII String mit einem Zeichengröße-WORD 
      // initialisiert, daher ist dieser Workaround nötig.
      pData += 2;
      udLen -= 2;
    END_IF;

    IF DataBuffer.SetSize( udLen ) = C_OK THEN
      DataBuffer.SetData( pData );
      m_udlen := udLen; //  set the length which is used in next method
      AddTermination();
      CalcCRC();
    END_IF;
  END_IF;

END_FUNCTION //VIRTUAL GLOBAL StringInternal::InitFromTable
//[#DEUTSCH]
//Kopiert den Inhalt des übergebenen Strings in das eigene String-Objekt.
//Die Inhalte beider Strings sind danach ident.
//[>pSrc]Zeiger auf den Quell-String
//[#ENGLISH]
// Copies the raw data from the passed string to the current one.
// The contents of the data blocks of both strings are the same
// afterwards.
//[>pSrc]pointer to source string
FUNCTION VIRTUAL GLOBAL StringInternal::StrCpy
	VAR_INPUT
		pSrc 	: ^StringInternal;
	END_VAR
VAR
	udLen		: UDINT;
END_VAR

	// Size includes 0-termination, considers style
	udLen	:= pSrc^.DataBuffer.GetSize();

  IF (SingleRealloc = 0) THEN //  If client is not set the function works like it did before rev. >= 1.8
    IF DataBuffer.SetSize( udLen ) = C_OK THEN

      _memcpy(GetData(), pSrc^.GetData(), udLen);

      m_udCRC		:= pSrc^.GetCRC();

      DataBuffer.UpdateToFile();
    END_IF;

  ELSE
    IF (udLen > DataBuffer.m_udLength) THEN
      IF (DataBuffer.SetSize(udLen) = C_OK) THEN
        _memcpy(GetData(), pSrc^.GetData(), udLen);
        m_udCRC		:= pSrc^.GetCRC();
        DataBuffer.UpdateToFile();

      END_IF;
    ELSE
      _memcpy(GetData(), pSrc^.GetData(), udLen);
      m_udCRC		:= pSrc^.GetCRC();
      DataBuffer.UpdateToFile();

    END_IF;
  END_IF;

END_FUNCTION //GLOBAL StringInternal::StrCpy
//[#DEUTSCH]
//Der String wird auf einen Leerstring gesetzt.
//[#ENGLISH]
// the string contents of the string are set to an empty string
FUNCTION VIRTUAL GLOBAL StringInternal::Clear
VAR
	pData : ^USINT;
END_VAR

  pData := DataBuffer.GetDataPtr();
	IF (SingleRealloc = 0) then //  If client is not set the function works like it did before rev. >= 1.8
    DataBuffer.SetSize(0);

  ELSE
    _memset(pData, 0, DataBuffer.m_udLength);

  END_IF;

	CalcCRC();

END_FUNCTION //GLOBAL StringInternal::Clear
//[#ENGLISH]
//The passed string is appended to the current string
//If the strings styles differ (ASCII/UNICODE), then the passed string
//will be converted to the current string's style prior to appending it.
//[>pSrc]pointer to string to append
//[#DEUTSCH]
//Der übergebene String wird an den eigenen String hinten angehängt.
//Wenn die Strings unterschiedliche Typen haben (ASCII/UNICODE), dann
//wird der übergebene String zuerst angepaßt, und dann erst angehängt.
//[>pSrc]Zeiger auf den anzuhängenden String
FUNCTION VIRTUAL GLOBAL StringInternal::StrCat
	VAR_INPUT
		pSrc 	: ^StringInternal;
	END_VAR
VAR
	udLenSrc	: UDINT;
	udLenDest	: UDINT;
	pCharSrc	: ^USINT;
END_VAR

	IF IsAscii() THEN
		IF pSrc^.IsUniCode() THEN	// convert source to target
			sCopy1^.StrCpy(pSrc);
			sCopy1^.ToAscii();
			pSrc	:= sCopy1;
		END_IF;
		pCharSrc := pSrc^.GetData();
		udLenSrc := pSrc^.GetLength() + 1;
	ELSE
		IF pSrc^.IsAscii() THEN		// convert source to target
			sCopy1^.StrCpy(pSrc);
			sCopy1^.ToUnicode();
			pSrc	:= sCopy1;
		END_IF;
		pCharSrc := pSrc^.GetData() + 2;
		udLenSrc := pSrc^.GetLength();
	END_IF;

	udLenDest	:= GetLength();

  IF (SingleRealloc = 0) THEN //  If client is not set the function works like it did before rev. >= 1.8
    IF DataBuffer.SetSize(udLenSrc + udLenDest) = C_OK THEN

      _memcpy(GetData()+udLenDest, pCharSrc, udLenSrc);
      AddTermination();
      CalcCRC();
      DataBuffer.UpdateToFile();

    END_IF;
  ELSE
    IF (udLenSrc + udLenDest > DataBuffer.m_udLength) THEN
      IF DataBuffer.SetSize(udLenSrc + udLenDest) = C_OK THEN

        _memcpy(GetData()+udLenDest, pCharSrc, udLenSrc);
        m_udlen := udLenSrc + udLenDest;  //  set the length which is used in next method
        AddTermination();
        CalcCRC();
        DataBuffer.UpdateToFile();

      END_IF;
    ELSE
      _memcpy(GetData()+udLenDest, pCharSrc, udLenSrc);
      m_udlen := udLenSrc + udLenDest;  //  set the length which is used in next method
      AddTermination();
      CalcCRC();
      DataBuffer.UpdateToFile();

    END_IF;
  END_IF;

	sCopy1^.Clear();

END_FUNCTION //GLOBAL StringInternal::StrCat
//[#ENGLISH]
// The function returns a CRC of the string's data buffer
// This CRC is recalculated everytime the contents are changed
//[<udCRC]32-bit-CRC
//[#DEUTSCH]
//Die Funktion liefert eine Prüfsumme über den Stringinhalt. Diese CRC
//wird bei jeder String-Änderung angepaßt.
//[<udCRC]32-bit-CRC
FUNCTION VIRTUAL GLOBAL StringInternal::GetCRC
VAR_OUTPUT
	udCRC		: UDINT;
END_VAR

	udCRC	:= m_udCRC;

END_FUNCTION //VIRTUAL GLOBAL StringInternal::GetCRC
//[#ENGLISH]
// Every time the string contents are changed, this function
// should be called to recalculate the check sum.
//[#DEUTSCH]
//Diese Funktion muß nach jeder String-Änderung aufgerufen werden,
//um die Prüfsumme über den Stringinhalt zu aktualisieren.
FUNCTION  StringInternal::CalcCRC

	m_udCRC := CRC32_Buffer(GetData(), DataBuffer.GetSize());

END_FUNCTION // StringInternal::CalcCRC
//[#ENGLISH]
// to have a defined state after configuration
// calculate the CRC
//[#DEUTSCH]
//Die CRC wird am Anfang berechnet, um diesen Wert zu initialisieren
FUNCTION VIRTUAL GLOBAL StringInternal::Init

  SingleRealloc := SingleRealloc.Read();
	CalcCRC();

END_FUNCTION //VIRTUAL GLOBAL StringInternal::Init
//[#ENGLISH]
//The two strings are compared case sensitive. The function returns 0
//if the strings are exactly the same, otherwise it returns <>0.
//If one of the two strings is in UNICODE, then the other is converted
//to UNICODE, too, before the comparison.
//None of the strings is changed!
//[>pStr]pointer to the 2nd string
//[<udNotEqual]0 .. equal, <>0 not equal
//[#DEUTSCH]
//Die beiden Strings werden mit Unterscheidung von Groß/Kleinschreibung
//verglichen. Die Funktion liefert 0, wenn die beiden Strings exakt
//gleich sind, sonst <>0.
//Wenn einer der beiden Strings UNICODE-Zeichen enthält, dann wird auch
//der andere String auf UNICODE transformiert, bevor der Vergleich
//durchgeführt wird.
//Keiner der beiden Strings wird dadurch verändert!
//[>pStr]Zeiger auf den 2. String
//[<udNotEqual]0 .. gleich, <>0 .. unterschiedlich
FUNCTION VIRTUAL GLOBAL StringInternal::StrCmp
	VAR_INPUT
		pStr 	: ^StringInternal;
	END_VAR
	VAR_OUTPUT
		udNotEqual 	: UDINT;
	END_VAR
VAR
	pStr2			: ^StringInternal;
END_VAR

	IF StrLen() <> pStr^.StrLen() THEN	//different number of characters
		udNotEqual := TRUE;
	ELSIF GetCharSize() = pStr^.GetCharSize() THEN	// strings with same style
		udNotEqual	:= _memcmp(GetData(), pStr^.GetData(), GetLength());
	ELSE
		IF IsAscii() THEN	// convert the ASCII string to UNICODE
			pStr2	:= this;
		ELSE
			pStr2	:= pStr;
			pStr	:= this;
		END_IF;
		sCopy1^.StrCpy(pStr2);
		sCopy1^.ToUniCode();

		IF sCopy1^.IsAscii() THEN
			udNotEqual	:= TRUE;			// i.e. alloc-problem
		ELSE
			udNotEqual	:= sCopy1^.StrCmp(pStr);	// same style, not recursive
		END_IF;

		sCopy1^.Clear();
	END_IF;

END_FUNCTION //GLOBAL StringInternal::StrCmp
//[#ENGLISH]
//The two strings are compared case insensitive. The function will return 0 if the
//strings are the same, otherwise it returns <>0.
//Comparing "Abc" with "Abc" or "Abc" with "ABC" will result in 0,
//comparing "PLC" with "SPS" will result in a value different from 0
//[>pStr]pointer to the 2nd string object
//[<udNotEqual]0 .. equal, <> 0 .. not equal
//[#DEUTSCH]
//Die beiden Strings werden ohne Berücksichtigung der Groß/Kleinschreibung
//miteinander verglichen. Die Funktion liefert für gleiche Strings 0,
//ansonsten einen Wert <> 0.
//Der Vergleich von "Abc" mit "Abc" oder von "Abc" mit "ABC" liefert 0,
//der Vergleich "PLC" mit "SPS" liefert einen Wert ungleich 0.
//[>pStr]Zeiger auf das 2. String Objekt
//[<udNotEqual]0 .. gleich, <> 0 .. ungleich
FUNCTION VIRTUAL GLOBAL StringInternal::StriCmp
	VAR_INPUT
		pStr 	: ^StringInternal;
	END_VAR
	VAR_OUTPUT
		udNotEqual 	: UDINT;
	END_VAR
VAR
	pStr2			: ^StringInternal;
END_VAR

	IF StrLen() <> pStr^.StrLen() THEN	//different number of characters
		udNotEqual := TRUE;
	ELSIF GetCharSize() = pStr^.GetCharSize() THEN	// strings with same style
		udNotEqual	:= _memicmp(GetData(), pStr^.GetData(), GetLength());
	ELSE
		IF IsAscii() THEN	// convert the ASCII string to UNICODE
			pStr2	:= this;
		ELSE
			pStr2	:= pStr;
			pStr	:= this;
		END_IF;
		sCopy1^.StrCpy(pStr2);
		sCopy1^.ToUniCode();

		IF sCopy1^.IsAscii() THEN
			udNotEqual	:= TRUE;			// i.e. alloc-problem
		ELSE
			udNotEqual	:= sCopy1^.StriCmp(pStr);	// same style, not recursive
		END_IF;

		sCopy1^.Clear();
	END_IF;

END_FUNCTION //GLOBAL StringInternal::StriCmp
//[#DEUTSCH]
//Die Funktion kopiert die letzten udCnt Zeichen des Strings in den
//Zielstring. Wenn die angegebene Zeichenzahl größer als die String-
//länge ist, wird nur der ursprüngliche String kopiert.
//[>udCnt]Anzahl der zu kopierenden Zeichen
//[>pStr]Zeiger auf den Zielstring
//[#ENGLISH]
//The function copies the specified number of characters to the destination string. If
//the specified number exceeds the string length, only the string contents are copied.
//[>udCnt]number of characters to copy
//[>pStr]pointer to destination string
FUNCTION VIRTUAL GLOBAL StringInternal::Right
	VAR_INPUT
		udCnt 	: UDINT;
		pStr 	: ^StringInternal;
	END_VAR
VAR
	udLen		: UDINT;
	udBufSize	: UDINT;
	pData		: ^USINT;
	usSize		: USINT;
END_VAR

	udLen	:= StrLen();
	IF udCnt > udLen THEN
		udCnt	:= udLen;
	END_IF;

	udCnt += 1;		// wg. 0-Ende-Zeichen

	usSize := GetCharSize();
	IF usSize = 2 THEN
		udBufSize := 2 + udCnt * 2;
	ELSE
		udBufSize := udCnt;
	END_IF;

  IF (SingleRealloc = 0) THEN //  If client is not set the function works like it did before rev. >= 1.8
    IF pStr^.DataBuffer.SetSize( udBufSize ) = C_OK THEN
      pData := pStr^.GetData();
      IF usSize = 2 THEN
        pData$^UINT^ := 0x0200;
        pdata += 2;
      END_IF;
      _memcpy(pData, GetData() + DataBuffer.GetSize() - udCnt * usSize, udCnt * usSize);
      pStr^.AddTermination();
      pStr^.CalcCRC();
      DataBuffer.UpdateToFile();
    END_IF;
  ELSE
    IF (udBufSize > DataBuffer.m_udLength) THEN
      IF pStr^.DataBuffer.SetSize( udBufSize ) = C_OK THEN
        pData := pStr^.GetData();
        IF usSize = 2 THEN
          pData$^UINT^ := 0x0200;
          pdata += 2;
        END_IF;
        _memcpy(pData, GetData() + (GetLength() + usSize) - udCnt * usSize, udCnt * usSize);
        m_udlen := udBufSize; //  set the length which is used in next method
        pStr^.AddTermination();
        pStr^.CalcCRC();
        DataBuffer.UpdateToFile();
      END_IF;
    ELSE
      pData := pStr^.GetData();
      IF usSize = 2 THEN
        pData$^UINT^ := 0x0200;
        pdata += 2;
      END_IF;
      _memcpy(pData, GetData() + (GetLength() + usSize) - udCnt * usSize, udCnt * usSize);
      m_udlen := udBufSize; //  set the length which is used in next method
      pStr^.AddTermination();
      pStr^.CalcCRC();
      DataBuffer.UpdateToFile();

    END_IF;
  END_IF;

END_FUNCTION //GLOBAL StringInternal::Right
//[#DEUTSCH]
//Der linke Teil des Strings wird in den Zielstring kopiert. Wenn
//die angegebene Zeichenzahl größer als die Stringlänge ist, wird
//nur der ursprüngliche String kopiert.
//[>udCnt]Anzahl der zu kopierenden Zeichen
//[>pStr]Zeiger auf den Zielstring
//[#ENGLISH]
//The left part of the string is copied to the specified string object. If udCnt exceeds
//the string length, only the string contents are copied
//[>udCnt]number of characters to extract
//[>pStr]pointer to the destination string
FUNCTION VIRTUAL GLOBAL StringInternal::Left
	VAR_INPUT
		udCnt 	: UDINT;
		pStr 	: ^StringInternal;
	END_VAR
VAR
	udLen		: UDINT;
	udBufSize	: UDINT;
END_VAR

	udLen	:= StrLen();
	IF udCnt > udLen THEN
		udCnt	:= udLen;
	END_IF;

	IF GetCharSize() = 2 THEN
		udBufSize := 2 + udCnt * 2;
	ELSE
		udBufSize := udCnt;
	END_IF;

  IF (SingleRealloc = 0) THEN //  If client is not set the function works like it did before rev. >= 1.8
    IF pStr^.DataBuffer.SetSize( udBufSize ) = C_OK THEN
      pStr^.DataBuffer.SetData( GetData() );
      pStr^.AddTermination();
      pStr^.CalcCRC();
    END_IF;

  ELSE
    IF (udBufSize > DataBuffer.m_udLength) THEN
      IF pStr^.DataBuffer.SetSize( udBufSize ) = C_OK THEN
        pStr^.DataBuffer.SetData( GetData() );
        m_udlen := udBufSize; //  set the length which is used in next method
        pStr^.AddTermination();
        pStr^.CalcCRC();
      END_IF;

    ELSE
      pStr^.DataBuffer.SetData( GetData() );
      m_udlen := udBufSize; //  set the length which is used in next method
      pStr^.AddTermination();
      pStr^.CalcCRC();
    END_IF;
  END_IF;

END_FUNCTION //GLOBAL StringInternal::Left
//[#DEUTSCH]
//[!GET_ADD_INFO]
// Klassenaghängige Zusatzinformation wird geliefert
//[#ENGLISH]
//[!GET_ADD_INFO]
// returns class specific additional information
FUNCTION VIRTUAL GLOBAL StringInternal::Data::NewInst
VAR_INPUT
	pPara		: ^CmdStruct;
	pResult		: ^results;
END_VAR
VAR_OUTPUT
	ret_code		: iprStates;
END_VAR

	ret_code	:= VirtualBaseInit::NewInst(pPara, pResult);

  CASE pPara^.uiCmd $ VirtualBaseInit::CmdData OF
    GET_ADD_INFO:
      pResult^.uiLng			    := sizeof(UINT) + 1 + 1 + sizeof(UDINT);
      pResult^.aData[0]		    := VBI_STRING;
      pResult^.aData[1]		    := GetCharSize();
      // erst ab version 1.31, kann anhand von pResult^.uiLng >= 8 ermittelt werden
      pResult^.aData[2]$UDINT := GetCRC();
  END_CASE;

END_FUNCTION //VIRTUAL GLOBAL StringInternal::Data::NewInst
//[#ENGLISH]
//All lower case letters are converted to upper case letters. The
//string object itself will be changed.
//[#DEUTSCH]
//Alle Kleinbuchstaben werden in Großbuchstaben konvertiert. Durch diese
//Funktion wird der String selbst geändert.
FUNCTION VIRTUAL GLOBAL StringInternal::StrUpr
VAR
  pa : ^usint;
  pu : ^uint;
END_VAR

	pa := GetData();
  if(pa <> NIL) then
    if IsAscii() then
			_strupr(pa);
    else
      pu := pa$^uint;
      while pu^ do
        if((pu^ >= 'a') & (pu^ <= 'z')) then
          pu^ -= 'a'-'A';
        end_if;
        pu += 2;
      end_while;
    end_if;
    
	  CalcCRC();
    DataBuffer.UpdateToFile();
	end_if;

END_FUNCTION
//[#ENGLISH]
//All upper case letters are converted to lower case letters. The
//string object itself will be changed.
//[#DEUTSCH]
//Alle Großbuchstaben werden in Kleinbuchstaben konvertiert. Durch diese
//Funktion wird der String selbst geändert.
FUNCTION VIRTUAL GLOBAL StringInternal::StrLwr
VAR
  pu : ^uint;
  pa : ^usint;
END_VAR

	pa := GetData();
  if(pa <> NIL) then
    if IsAscii() then
      while pa^ do
        if((pa^ <= 'Z') & (pa^ >= 'A')) then
          pa^ -= ('A'-'a');
        end_if;
        pa += 1;
      end_while;
    else
      pu := pa$^uint;
      while pu^ do
        if((pu^ <= 'Z') & (pu^ >= 'A')) then
          pu^ -= ('A'-'a');
        end_if;
        pu += 2;
      end_while;
    end_if;
    
	  CalcCRC();
    DataBuffer.UpdateToFile();
  end_if;

END_FUNCTION
//[#ENGLISH]
//The function searches for the given character in its string-buffer.
//It returns -1 if the character was not found, otherwise the index
//of the 1st matching character.
//[>uiChar]	character to search for
//[#DEUTSCH]
//Die Funktion sucht im String-Puffer nach dem angegebenen Zeichen.
//Sie liefert -1, wenn das Zeichen nicht gefunden wurde, ansonsten
//den Index des ersten übereinstimmenden Zeichens.
//[>uiChar]	Zeichen, nach dem gesucht werden soll
FUNCTION VIRTUAL GLOBAL StringInternal::StrChr
	VAR_INPUT
		uiChar 	: UINT;
	END_VAR
	VAR_OUTPUT
		udPosition 	: UDINT;
	END_VAR
VAR
  pu : ^uint;
  pa : ^usint;
END_VAR

	pa := GetData();
  if(pa <> NIL) then
    udPosition := 0;
    if IsAscii() then
      while pa^ do
        if(pa^ = uiChar) then
          return;
        end_if;
        pa         += 1;
        udPosition += 1;
      end_while;
    else
      pu := pa$^uint;
      while pu^ do
        if(pu^ = uiChar) then
          return;
        end_if;
        pu         += 2;
        udPosition += 1;
      end_while;
    end_if;
  end_if;

  udPosition := 16#FFFFFFFF;
  
END_FUNCTION
//[#ENGLISH]
//All characters of a UNICODE-string are converted to ASCII-characters.
//If a character can not be transformed to ASCII-code, it will be replaced
//by a SPACE-character (0x20).
//[#DEUTSCH]
//Die Zeichen eines UNICODE-STrings werden in ASCII-Code gewandelt. Wenn
//sich ein Zeichen nicht auf ASCII-Code abbilden läßt, dann wird es durch
//ein Leerzeichen (0x20) ersetzt.
FUNCTION VIRTUAL GLOBAL StringInternal::ToAscii
VAR
  pa : ^usint;
  pu : ^uint;
  noc : udint;
END_VAR

	pa := GetData();
  if(pa <> NIL) then
    if IsUnicode() then
      pu  := pa$^uint + 2;
      noc := 0;
      while(pu^) do
        if(pu^ < 256) then
          pa^ := pu$^usint^;
        else
          pa^ := 32; // space
        end_if;
        pu  += 2;
        pa  += 1;
        noc += 1;
      end_while;
      pa^ := 0;
      noc += 1;

      if(SingleRealloc = 0) then // If client is not set the function works like it did before rev. >= 1.8
        DataBuffer.SetSize(noc); // shrink buffer
      end_if;
      
      CalcCRC();
      DataBuffer.UpdateToFile();
    end_if;
  end_if;
  
END_FUNCTION
//[#ENGLISH]
//All characters of an ASCII-string are converted to UNICODE.
//[#DEUTSCH]
//Alle Zeichen eines ASCII-Strings werden auf UNICODE übersetzt.
FUNCTION VIRTUAL GLOBAL StringInternal::ToUniCode
VAR
  pa : ^usint;
  pu : ^uint;
  noc, len : udint;
END_VAR


  if IsAscii() then
    noc := GetLength() + 1;
    len := (noc + 1) * sizeof(uint); // unicodekennung + uni-0-string

    if(SingleRealloc = 0) then // If client is not set the function works like it did before rev. >= 1.8
      if(DataBuffer.SetSize(len) <> C_OK) then
        return;
      end_if;
    else
      if(len > DataBuffer.m_udLength) then
        if(DataBuffer.SetSize(len) <> C_OK) then
          return;
        end_if;
      end_if;
    end_if;

    pa  := GetData();

    if(pa <> NIL) then

      pu  := pa$^uint + len;
      pa  += noc;

      while noc do
        pu  -= 2;
        pa  -= 1;
        pu^ := pa^;
        noc -= 1;
      end_while;

      pu  -= 2;
      pu^ := 16#0200;  // unicode kennung
    
      CalcCRC();
      DataBuffer.UpdateToFile();

    end_if;
  end_if;

END_FUNCTION//[#ENGLISH]
//[#ENGLISH]
//Checks, if the string is terminated with a 0-character. If not, 
//a 0-character is appended. The string length is not changed by
//this function.
//[#DEUTSCH]
//Prüft, ob ein String mit 0 abgeschlossen ist. Wenn nicht, dann
//wird hier ein '\0'-Zeichen angehängt. Die Stringlänge ändert sich dadurch 
//nicht.
FUNCTION  StringInternal::AddTermination
VAR
	pa			:^USINT;
	udLen		: UDINT;
	usSize		: USINT;
  tmplen    : UDINT;
END_VAR

	usSize  := GetCharSize();

  if (SingleRealloc = 0) then
    udLen := DataBuffer.GetSize();  // total buffer size in bytes
  else
  	udLen	:= m_udlen; //  get number of chars
  end_if;

	IF((usSize = 1) & (udLen >= 1)) | ((usSize = 2) & (udLen >= 4)) THEN // space for at least on character
    pa := GetData();
    if pa <> nil then   // HlaWol v1.71
    
      pa += (udLen - usSize);
      if(usSize = 1) then
        if(pa^ = 0) then
          return; // ascii-0-terminated
        end_if;
      else
        if(pa^$uint = 0) then
          return; // uni-0-terminated
        end_if;
      end_if;
      
      tmplen := udLen + usSize;
      
      // allocate space for new 0-char
      IF (SingleRealloc = 0) THEN //  If client is not set the function works like it did before rev. >= 1.8
        IF DataBuffer.SetSize(tmplen) <> C_OK THEN
          RETURN;
        END_IF;
      ELSE
        IF ((udLen+usSize) > DataBuffer.m_udLength) THEN
          IF (DataBuffer.SetSize(tmplen) <> C_OK) then
            RETURN;

          END_IF;
        END_IF;
      END_IF;

      pa	:= GetData();
      if pa <> nil then   // HlaWol v1.71
        
        pa  += udLen;
        pa^ := 0;
        if(usSize = 2) then
          pa^$uint := 0;
        end_if;
        
      end_if;

      DataBuffer.UpdateToFile();
    end_if;      
	ELSE
		IF usSize = 1 THEN

      pa := GetData(); //  get the pointer
      IF(pa <> NIL) THEN //  got pointer?
        pa^ := 0; //  first char to zero because of changed method GetLength()
      END_IF;

      IF (SingleRealloc = 0) THEN //  If client is not set the function works like it did before rev. >= 1.8
        DataBuffer.SetSize(0);
      END_IF;
        
		ELSE
      IF (SingleRealloc = 0) THEN //  If client is not set the function works like it did before rev. >= 1.8
  			DataBuffer.SetSize(4);
      ELSE
        IF (DataBuffer.m_udLength < 4) THEN
          DataBuffer.SetSize(4);
        END_IF;
      END_IF;

			pa := GetData();
      if pa <> nil then   // HlaWol v1.71
        pa += 2;
        pa$^UINT^ := 0;
      end_if;
		END_IF;
    
    DataBuffer.UpdateToFile();
	END_IF;

END_FUNCTION // StringInternal::AddTermination 

//[#ENGLISH]
//Returns the number of characters in the string.
//The string length does not include the terminating zero.
//[#DEUTSCH]
//Liefert die Anzahl der Zeichen in einem String.
//Die Abschluß - Null ist nicht inkludiert.
FUNCTION VIRTUAL GLOBAL StringInternal::StrLen
	VAR_OUTPUT
		udLen 	: UDINT;
	END_VAR

  udLen := GetLength();
	if IsUnicode() then
    udLen :=  (udLen / 2) - 1;
	END_IF;

END_FUNCTION
//[#ENGLISH]
//Set a character to the String at a given position
//[>pData]pointer to source
//[>udAt]offset within the string-buffer
//[#DEUTSCH]
//Setzt ein Zeichen an einer bestimmten Position des Strings
//[>pData]Zeigt auf die Quelldaten
//[>udAt]Position im String an der das Zeichen gesetzt wird
FUNCTION VIRTUAL GLOBAL StringInternal::SetDataAt
	VAR_INPUT
		pData 	: ^UINT;
		udAt 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
VAR
	udSize		: UDINT;
END_VAR
	
	IF IsUniCode() THEN
		udSize := 2;
		udAt *= 2;
		//++pr 10.12.2004: 
		//	Wenn udAt 0 ist, dann sollte es meiner Meinung nach auf das 1. Zeichen 
		//	und nicht auf das Zeichengrößen-Wort zeigen.
		//	Wg. der Kompatibilität zu früheren Versionen habe ich aber nichts geändert.
	ELSE
		udSize := 1;
	END_IF;

	ret_code := DataBuffer.SetDataAt(pData$^USINT, udSize, udAt);

	CalcCRC();

END_FUNCTION //GLOBAL StringInternal::SetDataAt
//[#ENGLISH]
//returns 1 for ASCII strings and 2 for Unicode strings
//[<usSize]size of one character in the string (ASCII vs. Unicode)
FUNCTION VIRTUAL GLOBAL StringInternal::GetCharSize
	VAR_OUTPUT
		usSize 	: USINT;
	END_VAR
VAR
	pu : ^uint;
END_VAR

  usSize := 1;

  pu$^usint := GetData();
  if(pu <> NIL) then
    if(DataBuffer.GetSize() >= 2) then
      if(pu^ = 16#0200) then
        usSize := 2;
      end_if;
    end_if;
  end_if;

END_FUNCTION //GLOBAL StringInternal::GetCharSize


FUNCTION VIRTUAL GLOBAL StringInternal::Data::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	output := NIL $ UDINT;

END_FUNCTION //VIRTUAL GLOBAL StringInternal::Data::Read
//[#ENGLISH]
// input is taken as a pointer to another string object. StrCpy is called to copy the
// string into the current object.
//[>input] pointer to a source string
//[#DEUTSCH]
//Der Übergabe-Parameter wird als Zeiger auf ein String-Objekt interpretiert. Die Funktion kopiert
//den Inhalt dieses String in den eigenen String.
//[>input] Zeiger auf den Quellstring


FUNCTION VIRTUAL GLOBAL StringInternal::Data::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

  Data := input;
	StrCpy(input$^StringInternal);
  result := Data;


END_FUNCTION //VIRTUAL GLOBAL StringInternal::Data::Write
//[#ENGLISH]
// returns the length of the raw data (without termination-0)
//[<udLen]string length
//[#DEUTSCH]
//liefert die Länge der Strings-Rohdaten ohne Abschluß-Null
//[<udLen]Stringlänge


FUNCTION VIRTUAL GLOBAL StringInternal::WriteDataOffUni
VAR_INPUT
  udlen 	: UDINT;
  udOff 	: UDINT;
  pData 	: ^UINT;
  usSize 	: USINT;
END_VAR
VAR
	ptmpmem : ^UINT;
  tmplen  : UDINT;
END_VAR
  
  ptmpmem := NIL;
  tmplen := udOff + udlen;


  // --- HubChr v1.81 in case of ASCII string, length of 1 character DOES make sense!
  IF pData THEN 
    IF usSize = 1 & udLen >= 1 then
      WriteDataOff(udLen, udOff, pData$^USINT);
    ELSIF usSize = 2 & udLen >= 2 THEN
  // --- End HubChr v1.81

      IF (udOff = 0) THEN
        //  allcoate with extern function
        ptmpmem$^void := _alloc(udlen + 2);

        //  check if we get a valid pointer
        IF (ptmpmem <> NIL) THEN 
          //  write the identifier in the first 2 bytes
          ptmpmem^ := 16#0200;

          //  copy the string to the new memoryblock with the identifier
          _memcpy(ptmpmem + 2, pData, udlen);
          //  the len is increased by 2 bytes
          tmplen += 2;

          //  we call the WriteDataOff method with the new len and the new memory block
          WriteDataOff(udLen:= tmplen, udOff:= udOff, pData:= ptmpmem$^USINT);
          //  the string is written so we can free the memory block again
          _free(ptmpmem);
        END_IF;
      ELSE
        //  increase the offset, because the identifier is in front of the string
        udOff += 2;
        //  call write method with new offset
        WriteDataOff(udlen, udOff, pData$^USINT);

      END_IF;
    END_IF;
  END_IF;

END_FUNCTION
