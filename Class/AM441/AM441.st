//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_AM441             1017

#define AM441_ADDR_CYC_WRITE        16#000
#define AM441_ADDR_CYC_READ         16#080
#define AM441_ADDR_CFG_FIRMWARE     16#100
#define AM441_ADDR_STATE_FIRMWARE   16#180

#define AM441_SDO_RESPONSE_TIMEOUT  SDIAS_SDO_TIMEOUT * 2

#define AM441_NUMBER_OF_ANALOG_IN   4
#define AM441_INVALID_VALUE         16#80000010$DINT

#define AM441_FIRMWARE_MIN          -10000
#define AM441_FIRMWARE_MAX          10000
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "AM441"
	Revision           = "1.30"
	GUID               = "{013A285A-3668-4EBC-82FC-AEECF8DC9E5A}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(502,120)"
	Comment            = "SDIAS Analog Mixed Module&#13;&#10;4 x Analog In +/- 10V&#13;&#10;4 x Analog In +/- 10V">
	<Channels>
		<Server Name="AI1" GUID="{997D0AA9-6A34-4859-A5FF-504117B4D666}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input. Status query over read().&#13;&#10;The invalid value in case of cable break is 16#80000010."/>
		<Server Name="AI2" GUID="{5768D9EB-1A08-4C27-B160-83AFF387A014}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input. Status query over read().&#13;&#10;The invalid value in case of cable break is 16#80000010."/>
		<Server Name="AI3" GUID="{5271DDFA-3324-4A1A-A69C-21A7C73D788F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input. Status query over read().&#13;&#10;The invalid value in case of cable break is 16#80000010."/>
		<Server Name="AI4" GUID="{EEC94579-D4CD-41B6-A28A-A0E6EA259788}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input. Status query over read().&#13;&#10;The invalid value in case of cable break is 16#80000010."/>
		<Server Name="AO1" GUID="{497A3B87-EC17-41B9-AD75-A705B7E7FC36}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Analog output"/>
		<Server Name="AO2" GUID="{C95D885A-335A-446F-B19B-FD5366FCA18E}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Analog output"/>
		<Server Name="AO3" GUID="{823B4B61-CD87-4ED1-9B49-81D90AE2DDD1}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Analog output"/>
		<Server Name="AO4" GUID="{87C084FC-EBBE-4F1C-9983-790E6BAD54D7}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Analog output"/>
		<Server Name="ErrorBits" GUID="{DDCBCDCF-72A1-4A4A-8260-32FBB5E5580D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Error Bits:&#13;&#10;Bit0...Reserved&#13;&#10;Bit1...No Sync&#13;&#10;Bit2...Flash data CRC error&#13;&#10;Bit3...Ram data CRC error&#13;&#10;Bit4...No valid EEPROM Version&#13;&#10;....&#13;&#10;Bit16...Cable break on AI1&#13;&#10;Bit17...Cable break on AI2&#13;&#10;Bit18...Cable break on AI3&#13;&#10;Bit19...Cable break on AI4&#13;&#10;Bit20...Reference Supply Voltage too low&#13;&#10;Bit21...Current on analog input is too high"/>
		<Server Name="FirmwareVersion" GUID="{D6D7FFCC-2DEA-4A4F-B6BE-6E73D185E6EC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Version of the used firmware&#13;&#10;&#13;&#10;e.g. 16#100 means v1.0"/>
		<Server Name="RefVoltageOK" GUID="{B6A1D0D0-D056-4846-BD6B-B19E0F593C0C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Reference Supply Voltage status"/>
		<Client Name="AI1_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz&#13;&#10;&#13;&#10;"/>
		<Client Name="AI1_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of analog input can be selected by this client&#13;&#10;(corresponds to +/- 10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI1_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of analog input can be selected by this client&#13;&#10;(corresponds to +/- 10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI1Config" Required="false" Internal="false" Comment="0 = AIx used as analog in&#13;&#10;1 = AIx used as analog in with ground reference&#13;&#10;Range -10V...+10V&#13;&#10;"/>
		<Client Name="AI2_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz&#13;&#10;&#13;&#10;"/>
		<Client Name="AI2_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of analog input can be selected by this client&#13;&#10;(corresponds to +/- 10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI2_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of analog input can be selected by this client&#13;&#10;(corresponds to +/- 10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI2Config" Required="false" Internal="false" Comment="0 = AIx used as analog in&#13;&#10;1 = AIx used as analog in with ground reference&#13;&#10;Range -10V...+10V&#13;&#10;"/>
		<Client Name="AI3_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz&#13;&#10;&#13;&#10;"/>
		<Client Name="AI3_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of analog input can be selected by this client&#13;&#10;(corresponds to +/- 10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI3_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of analog input can be selected by this client&#13;&#10;(corresponds to +/- 10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI3Config" Required="false" Internal="false" Comment="0 = AIx used as analog in&#13;&#10;1 = AIx used as analog in with ground reference&#13;&#10;Range -10V...+10V&#13;&#10;"/>
		<Client Name="AI4_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz&#13;&#10;&#13;&#10;"/>
		<Client Name="AI4_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of analog input can be selected by this client&#13;&#10;(corresponds to +/- 10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI4_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of analog input can be selected by this client&#13;&#10;(corresponds to +/- 10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI4Config" Required="false" Internal="false" Comment="0 = AIx used as analog in&#13;&#10;1 = AIx used as analog in with ground reference&#13;&#10;Range -10V...+10V&#13;&#10;"/>
		<Client Name="AO1_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of analog output can be selected by this client &#13;&#10;(corresponds +/- 10V).&#13;&#10;As initvalue!"/>
		<Client Name="AO1_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of analog output can be selected by this client &#13;&#10;(corresponds +/- 10V).&#13;&#10;As initvalue!"/>
		<Client Name="AO2_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of analog output can be selected by this client &#13;&#10;(corresponds +/- 10V).&#13;&#10;As initvalue!"/>
		<Client Name="AO2_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of analog output can be selected by this client &#13;&#10;(corresponds +/- 10V).&#13;&#10;As initvalue!"/>
		<Client Name="AO3_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of analog output can be selected by this client &#13;&#10;(corresponds +/- 10V).&#13;&#10;As initvalue!"/>
		<Client Name="AO3_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of analog output can be selected by this client &#13;&#10;(corresponds +/- 10V).&#13;&#10;As initvalue!"/>
		<Client Name="AO4_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of analog output can be selected by this client &#13;&#10;(corresponds +/- 10V).&#13;&#10;As initvalue!"/>
		<Client Name="AO4_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of analog output can be selected by this client &#13;&#10;(corresponds +/- 10V).&#13;&#10;As initvalue!"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="BeiWol"/>
		<Dokumentation Revision="1.30" Date="12.07.2016" Author="SeiChr" Company="Sigmatek" Description="Added Values for the total Current calculation. SA 31571"/>
		<Dokumentation Revision="1.29" Date="01.03.2016" Author="EisMic" Company="Sigmatek" Description="Corrected BoundExceed Error in base class at Write method of LEDControl Server when Place = LSL_DEACTIVATED."/>
		<Dokumentation Revision="1.28" Date="23.02.2016" Author="PieSte" Company="Sigmatek" Description="Add support for min range greater max range."/>
		<Dokumentation Revision="1.27" Date="17.06.2015" Author="EisMic" Company="Sigmatek" Description="The servers FPGAVersion, SerialNo, Device ID and status and input servers are now not reset anymore when the module is disconnected."/>
		<Dokumentation Revision="1.26" Date="16.04.2015" Author="EisMic&#13;&#10;LanSte" Company="Sigmatek" Description="Added support for visualisation in graphical hardware editor.&#13;&#10;Added support for calculating resources for graphical hardware editor."/>
		<Dokumentation Revision="1.25" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Added HW Version for sdias clients."/>
		<Dokumentation Revision="1.24" Date="11.02.2015" Author="PieSte" Company="Sigmatek" Description="Corrected read spi data for hardwaretree in methode GetSPIDataFromID from baseclass."/>
		<Dokumentation Revision="1.23" Date="18.11.2014" Author="PieSte" Company="Sigmatek" Description="Added possibility  to read more data from spi flash then one sdo access.&#13;&#10;Set methode GetDeviceID to global.&#13;&#10;Add methode to calculate checksum of spi flash."/>
		<Dokumentation Revision="1.22" Date="04.07.2014" Author="EisMic" Company="Sigmatek" Description="Added support for reading hardware diagnosis and hardwaretree entry."/>
		<Dokumentation Revision="1.21" Date="07.03.2014" Author="EisMic" Company="Sigmatek" Description=" Corrected comment of server Firmwareversion"/>
		<Dokumentation Revision="1.20" Date="20.01.2014" Author="PieSte" Company="Sigmatek" Description="Read Client Required and Place in Init SdiasBase"/>
		<Dokumentation Revision="1.10" Date="05.12.2013" Author="RamAnd" Company="Sigmatek" Description="Changed login mechanism to sdias manager class to be independent of bus accesses."/>
		<Dokumentation Revision="1.0" Date="03.09.2013" Author="BeiWol" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
	<Network Name="AM441">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{7CBC63CA-0422-45ED-A120-9E10D4AFBCB7}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

AM441 : CLASS
: SdiasBase
	TYPE
	  t_AM_Errors : BINT  //! <Type Public="true" Comment="AM specific errors" Name="t_AM_Errors"/>
	  [
	    1 CableBreakAI1,  //! <Type Comment="Analog input cable break bit" Name="t_AM_Errors.CableBreakAI1"/>
	    2 CableBreakAI2,  //! <Type Comment="Analog input cable break bit" Name="t_AM_Errors.CableBreakAI2"/>
	    3 CableBreakAI3,  //! <Type Comment="Analog input cable break bit" Name="t_AM_Errors.CableBreakAI3"/>
	    4 CableBreakAI4,  //! <Type Comment="Analog input cable break bit" Name="t_AM_Errors.CableBreakAI4"/>
	    5 LowReference,  //! <Type Comment="Reference Supply Voltage is too low." Name="t_AM_Errors.LowReference"/>
	    6 AiOvercurrent,  //! <Type Comment="Analog input current is too high." Name="t_AM_Errors.AiOvercurrent"/>
	  ];
	  t_bi_Selection : BINT  //! <Type Comment="Analog in default or ground reference selection." Name="t_bi_Selection"/>
	  [
	    1 AI1_Def0_Ground1,  //! <Type Comment="Select bit for analog input&#13;&#10;0 = default input&#13;&#10;1 = ground reference input" Name="t_bi_Selection.AI1_Def0_Ground1"/>
	    2 AI2_Def0_Ground1,  //! <Type Comment="Select bit for analog input&#13;&#10;0 = default input&#13;&#10;1 = ground reference input" Name="t_bi_Selection.AI2_Def0_Ground1"/>
	    3 AI3_Def0_Ground1,  //! <Type Comment="Select bit for analog input&#13;&#10;0 = default input&#13;&#10;1 = ground reference input" Name="t_bi_Selection.AI3_Def0_Ground1"/>
	    4 AI4_Def0_Ground1,  //! <Type Comment="Select bit for analog input&#13;&#10;0 = default input&#13;&#10;1 = ground reference input" Name="t_bi_Selection.AI4_Def0_Ground1"/>
	  ];
	  t_e_InitSSW :  //! <Type Comment="State definition for Initialization." Name="t_e_InitSSW"/>
	  (
	    Init_Variables,  //! <Type Comment="Initialize default value." Name="t_e_InitSSW.Init_Variables"/>
	    Init_Firmware,  //! <Type Comment="SDO write access to firmware (writes config data)." Name="t_e_InitSSW.Init_Firmware"/>
	    Init_GetStateFW,  //! <Type Comment="SDO read access to firmware (read status data)." Name="t_e_InitSSW.Init_GetStateFW"/>
	    Init_Finish,  //! <Type Comment="Finish initialization." Name="t_e_InitSSW.Init_Finish"/>
	    Init_Error  //! <Type Comment="Error in initialization." Name="t_e_InitSSW.Init_Error"/>
	  )$UDINT;
	  t_e_SDOState :  //! <Type Comment="SDO Response states." Name="t_e_SDOState"/>
	  (
	    SDO_idle,  //! <Type Comment="No SDO transmission." Name="t_e_SDOState.SDO_idle"/>
	    SDO_wait,  //! <Type Comment="SDO transmission in progress." Name="t_e_SDOState.SDO_wait"/>
	    SDO_valid  //! <Type Comment="SDO transmission succeeded." Name="t_e_SDOState.SDO_valid"/>
	  )$UDINT;
#pragma pack(push, 1)
	  t_MinMaxRange : STRUCT
	    MinRangeValue : DINT;
	    MaxRangeValue : DINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_StandardModus : STRUCT  //! <Type Comment="Configuration data for module." Name="t_s_StandardModus"/>
	    Ai_mode : t_bi_Selection;  //! <Type Comment="Analog input settings" Name="t_s_StandardModus.Ai_mode"/>
	    uiAI1_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_s_StandardModus.uiAI1_Freq"/>
	    uiAI2_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_s_StandardModus.uiAI2_Freq"/>
	    uiAI3_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_s_StandardModus.uiAI3_Freq"/>
	    uiAI4_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_s_StandardModus.uiAI4_Freq"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_FWConfiguration : STRUCT  //! <Type Comment="Configuration Data of from HW-Class to Firmware." Name="t_s_FWConfiguration"/>
	    hCRC : HINT;  //! <Type Comment="Checksum of data block." Name="t_s_FWConfiguration.hCRC"/>
	    uDataLength : UINT;  //! <Type Comment="Length of data block." Name="t_s_FWConfiguration.uDataLength"/>
	    Info : BSINT  //! <Type Comment="Info (Special-Purpose / Statusbits)" Name="t_s_FWConfiguration.Info"/>
	    [
	      1 PMBModus,  //! <Type Comment="Mode for Firmware&#13;&#10;&#13;&#10;0 = standard Mode&#13;&#10;1 = PMB Mode" Name="t_s_FWConfiguration.Info.PMBModus"/>
	      2 BootLoaderUpdateReqest,  //! <Type Comment="Update request for bootloader." Name="t_s_FWConfiguration.Info.BootLoaderUpdateReqest"/>
	    ];
	    Reserved : USINT;  //! <Type Comment="Reserved Byte for 2 Byte alignment." Name="t_s_FWConfiguration.Reserved"/>
	    StandardModus : t_s_StandardModus;  //! <Type Comment="Module configuration" Name="t_s_FWConfiguration.StandardModus"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_FWState : STRUCT  //! <Type Comment="Configuration Data of from Firmware to HW-Class." Name="t_s_FWState"/>
	    hCRC : UINT;  //! <Type Comment="Checksum value for data block." Name="t_s_FWState.hCRC"/>
	    uDataLength : UINT;  //! <Type Comment="Length of data block." Name="t_s_FWState.uDataLength"/>
	    hFWVersion : HINT;  //! <Type Comment="Firmware version" Name="t_s_FWState.hFWVersion"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ReadData : STRUCT  //! <Type Comment="Cyclic read memory space." Name="t_s_ReadData"/>
	    Status : t_b_SdiasFWState;
	    iAnalogIn1 : INT;  //! <Type Comment="Analog in value." Name="t_s_ReadData.iAnalogIn1"/>
	    iAnalogIn2 : INT;  //! <Type Comment="Analog in value." Name="t_s_ReadData.iAnalogIn2"/>
	    iAnalogIn3 : INT;  //! <Type Comment="Analog in value." Name="t_s_ReadData.iAnalogIn3"/>
	    iAnalogIn4 : INT;  //! <Type Comment="Analog in value." Name="t_s_ReadData.iAnalogIn4"/>
	    AM_Errors : t_AM_Errors;  //! <Type Comment="Module specific errors." Name="t_s_ReadData.AM_Errors"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_TwoOutputs : STRUCT  //! <Type Comment="Concatenate two Outputs." Name="t_s_TwoOutputs"/>
	    Output1 : INT;  //! <Type Comment="First output" Name="t_s_TwoOutputs.Output1"/>
	    Output2 : INT;  //! <Type Comment="Second output" Name="t_s_TwoOutputs.Output2"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_WriteData : STRUCT  //! <Type Comment="Cyclic data for hardware." Name="t_s_WriteData"/>
	    AO1_2 : t_s_TwoOutputs;  //! <Type Comment="Output 1 and Output 2" Name="t_s_WriteData.AO1_2"/>
	    AO3_4 : t_s_TwoOutputs;  //! <Type Comment="Output 3 and Output 4" Name="t_s_WriteData.AO3_4"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SDIAS_ErrorBits_AM441 : STRUCT  //! <Type Public="true" Comment="Concatenation of error bits." Name="t_SDIAS_ErrorBits_AM441"/>
	    StandardErrors : t_b_SdiasFWState;  //! <Type Comment="Standard errors" Name="t_SDIAS_ErrorBits_AM441.StandardErrors"/>
	    AM_Errors : t_AM_Errors;  //! <Type Comment="Module specific errors." Name="t_SDIAS_ErrorBits_AM441.AM_Errors"/>
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	FirmwareVersion 	: SvrCh_HDINT;
	ErrorBits 	: SvrCh_t_SDIAS_ErrorBits_AM441_PTofCls_AM441;
	AI1 	: SvrCh_DINT;
	AI2 	: SvrCh_DINT;
	AI3 	: SvrCh_DINT;
	AI4 	: SvrCh_DINT;
	AO1 	: SvrCh_DINT;
	AO2 	: SvrCh_DINT;
	AO3 	: SvrCh_DINT;
	AO4 	: SvrCh_DINT;
	RefVoltageOK 	: SvrCh_DINT;
  //Clients:
	AI1Config 	: CltCh_DINT;
	AI1_Freq 	: CltCh_UDINT;
	AI1_Min 	: CltCh_DINT;
	AI1_Max 	: CltCh_DINT;
	AI2Config 	: CltCh_DINT;
	AI2_Freq 	: CltCh_UDINT;
	AI2_Min 	: CltCh_DINT;
	AI2_Max 	: CltCh_DINT;
	AI3Config 	: CltCh_DINT;
	AI3_Freq 	: CltCh_UDINT;
	AI3_Min 	: CltCh_DINT;
	AI3_Max 	: CltCh_DINT;
	AI4Config 	: CltCh_DINT;
	AI4_Freq 	: CltCh_UDINT;
	AI4_Min 	: CltCh_DINT;
	AI4_Max 	: CltCh_DINT;
	AO1_Min 	: CltCh_DINT;
	AO1_Max 	: CltCh_DINT;
	AO2_Min 	: CltCh_DINT;
	AO2_Max 	: CltCh_DINT;
	AO3_Min 	: CltCh_DINT;
	AO3_Max 	: CltCh_DINT;
	AO4_Min 	: CltCh_DINT;
	AO4_Max 	: CltCh_DINT;
  //Variables:
		aAIRange : ARRAY [0..AM441_NUMBER_OF_ANALOG_IN-1] OF DINT;
			//! <Variable Comment="RangeInformations for the Inputs." Name="aAIRange"/>
		eInitSSW 	: t_e_InitSSW;			//! <Variable Comment="Initialisation Statemachine." Name="eInitSSW"/>
		eInitSSWErrorStep 	: t_e_InitSSW;			//! <Variable Comment="Initialisation Statemachine in case of an Error." Name="eInitSSWErrorStep"/>
		eResponseState 	: t_e_SDOState;			//! <Variable Comment="Actual Response State of the SDO Communication." Name="eResponseState"/>
		pReadData 	: ^t_s_ReadData;			//! <Variable Comment="Read-Data from the Module." Name="pReadData"/>
		sFWConfiguration 	: t_s_FWConfiguration;			//! <Variable Comment="Configuration Data for the Firmware." Name="sFWConfiguration"/>
		sFWState 	: t_s_FWState;			//! <Variable Comment="FW Informations of the Module." Name="sFWState"/>
		udSDOTimeout 	: UDINT;			//! <Variable Comment="Timeout for SDO-Communication." Name="udSDOTimeout"/>
		bsChangeFlag : BSINT
		[
		  1 AO1_2,  //! <Variable Comment="Output 1 or Output 2 has changed." Name="bsChangeFlag.AO1_2"/>
		  2 AO3_4,  //! <Variable Comment="Output 1 or Output 2 has changed." Name="bsChangeFlag.AO3_4"/>
		];
			//! <Variable Comment="Bitfield indicates Change of Output-Server." Name="bsChangeFlag"/>
		pWriteData 	: ^t_s_WriteData;			//! <Variable Comment="WriteData of the Module." Name="pWriteData"/>
		sModuleStatus 	: t_s_ReadData;			//! <Variable Comment="Actual Status of the Module, which gets read from the Hardware." Name="sModuleStatus"/>
		sOutputValues 	: t_s_WriteData;			//! <Variable Comment="Outputvalues for the Hardware." Name="sOutputValues"/>
		aMinMaxOutput : ARRAY [0..3] OF t_MinMaxRange;

  //Functions:
				//! <Function Comment="Constructor of Class." Name="AM441"/>
	FUNCTION AM441
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Realtime Update Methode which runs in PostScan." Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode is used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GetFWVersion
		VAR_INPUT
			pData 	: ^CHAR;
			Length 	: UDINT;
		END_VAR;
				//! <Function Comment="Lookup-Methode to get the Frequency-Setting for the uC." Name="SetFrequency"/>
	FUNCTION SetFrequency
		VAR_INPUT
			ClientValue 	: UDINT;			//! <Variable Comment="Input-Value for the uC" Name="SetFrequency.ClientValue"/>
		END_VAR
		VAR_OUTPUT
			Frequency 	: UINT;			//! <Variable Comment="Result for the uC." Name="SetFrequency.Frequency"/>
		END_VAR;
	
	FUNCTION CalcScaleInv
		VAR_INPUT
			ScaleVal 	: DINT;			//! <Variable Comment="Value to Scale into Binary Value." Name="CalcScaleInv.ScaleVal"/>
			MinVal 	: DINT;			//! <Variable Comment="Minimum Value." Name="CalcScaleInv.MinVal"/>
			MaxVal 	: DINT;			//! <Variable Comment="Maximum Value." Name="CalcScaleInv.MaxVal"/>
		END_VAR
		VAR_OUTPUT
			BinVal 	: INT;			//! <Variable Comment="Binary Value as Result." Name="CalcScaleInv.BinVal"/>
		END_VAR;
	
	FUNCTION GetMinMaxRange
		VAR_INPUT
			ClientMinRange 	: DINT;
			ClientMaxRange 	: DINT;
			pMinMaxValue 	: ^t_MinMaxRange;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AO1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AO2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AO3::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AO4::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB AM441::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_AM441
1$UINT, 30$UINT, (SIZEOF(::AM441))$UINT, 
11$UINT, 24$UINT, 0$UINT, 
TO_UDINT(56211589), "AM441", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 52$UINT, //Baseclass
//Servers:
(::AM441.FirmwareVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(389440282), "FirmwareVersion", 
(::AM441.ErrorBits.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(259769398), "ErrorBits", 
(::AM441.AI1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4269591187), "AI1", 
(::AM441.AI2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1735760681), "AI2", 
(::AM441.AI3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(275950527), "AI3", 
(::AM441.AI4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2383822364), "AI4", 
(::AM441.AO1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2821090581), "AO1", 
(::AM441.AO2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(825179311), "AO2", 
(::AM441.AO3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1177029689), "AO3", 
(::AM441.AO4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3628898714), "AO4", 
(::AM441.RefVoltageOK.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4186040419), "RefVoltageOK", 
//Clients:
(::AM441.AI1Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2190884243), "AI1Config", 
(::AM441.AI1_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1690732223), "AI1_Freq", 
(::AM441.AI1_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2432037533), "AI1_Min", 
(::AM441.AI1_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2901986756), "AI1_Max", 
(::AM441.AI2Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3011389198), "AI2Config", 
(::AM441.AI2_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3797087249), "AI2_Freq", 
(::AM441.AI2_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3612706893), "AI2_Min", 
(::AM441.AI2_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3948459796), "AI2_Max", 
(::AM441.AI3Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(352922810), "AI3Config", 
(::AM441.AI3_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(688793524), "AI3_Freq", 
(::AM441.AI3_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3929383421), "AI3_Min", 
(::AM441.AI3_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3594034852), "AI3_Max", 
(::AM441.AI4Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3501068852), "AI4Config", 
(::AM441.AI4_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(873142028), "AI4_Freq", 
(::AM441.AI4_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1477803501), "AI4_Min", 
(::AM441.AI4_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1679311540), "AI4_Max", 
(::AM441.AO1_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1185681792), "AO1_Min", 
(::AM441.AO1_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2057383641), "AO1_Max", 
(::AM441.AO2_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(17591120), "AO2_Min", 
(::AM441.AO2_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1023497225), "AO2_Max", 
(::AM441.AO3_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1013727968), "AO3_Min", 
(::AM441.AO3_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(6389177), "AO3_Max", 
(::AM441.AO4_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2387386096), "AO4_Min", 
(::AM441.AO4_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2990645673), "AO4_Max", 
END_FUNCTION


#define USER_CNT_AM441 18

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_AM441] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION AM441::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_AM441;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #GetDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #GetFWVersion();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AO1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AO1::Write() );
	IF AO1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AO2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AO2::Write() );
	IF AO2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AO3.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AO3::Write() );
	IF AO3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AO4.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AO4::Write() );
	IF AO4.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= AM441();

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL AM441::UpdateRt
  VAR
  	sTempReadData : t_s_ReadData;
  END_VAR

  sTempReadData := pReadData^;

  // set Status
  ErrorBits.StandardErrors  := sTempReadData.Status;
  ErrorBits.AM_Errors        := sTempReadData.AM_Errors;
  
  if (sTempReadData.AM_Errors.CableBreakAI1) then
    AI1 := AM441_INVALID_VALUE;
  else
    AI1 := AI1_Min + (aAIRange[0] * (sTempReadData.iAnalogIn1 - AM441_FIRMWARE_MIN)) / (AM441_FIRMWARE_MAX - AM441_FIRMWARE_MIN);
  end_if;
  
  if (sTempReadData.AM_Errors.CableBreakAI2) then
    AI2 := AM441_INVALID_VALUE;
  else
    AI2 := AI2_Min + (aAIRange[1] * (sTempReadData.iAnalogIn2 - AM441_FIRMWARE_MIN)) / (AM441_FIRMWARE_MAX - AM441_FIRMWARE_MIN);
  end_if;
  
  if (sTempReadData.AM_Errors.CableBreakAI3) then
    AI3 := AM441_INVALID_VALUE;
  else
    AI3 := AI3_Min + (aAIRange[2] * (sTempReadData.iAnalogIn3 - AM441_FIRMWARE_MIN)) / (AM441_FIRMWARE_MAX - AM441_FIRMWARE_MIN);
  end_if;
  
  if (sTempReadData.AM_Errors.CableBreakAI4) then
    AI4 := AM441_INVALID_VALUE;
  else
    AI4 := AI4_Min + (aAIRange[3] * (sTempReadData.iAnalogIn4 - AM441_FIRMWARE_MIN)) / (AM441_FIRMWARE_MAX - AM441_FIRMWARE_MIN);
  end_if;

  // set Error server
  RefVoltageOK := sTempReadData.AM_Errors.LowReference XOR 1;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM441::UpdateRtPostScan

  if bsChangeFlag then
    if bsChangeFlag.AO1_2 then   
      // on 4 byte access is faster than two 2 byte accesses on PCI
      pWriteData^.AO1_2 := sOutputValues.AO1_2;
    end_if;
   
    if bsChangeFlag.AO3_4 then     
      // on 4 byte access is faster than two 2 byte accesses on PCI
      pWriteData^.AO3_4 := sOutputValues.AO3_4;
    end_if;

    bsChangeFlag      := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM441::ConnectEvent

  //Read Access
  if DefaultAccesses.ReadAccess.pControlByte then
    pReadData := DefaultAccesses.ReadAccess.pData$^t_s_ReadData;

    //Start Read-Access to Module (Set ControlWord in DPRam)
    DefaultAccesses.ReadAccess.pControlByte^.EnableDO := true;
  else
    //No ControlWord available
    eInitState := _DOHandleInvalid;
    return;
  end_if;
  
  //Write Access
  if DefaultAccesses.WriteAccess.pControlByte then
    pWriteData := DefaultAccesses.WriteAccess.pData$^t_s_WriteData;

    //Start Write-Access to Module (Set ControlWord in DPRam)
    DefaultAccesses.WriteAccess.pControlByte^.EnableDO := true;
  else  
    //No ControlWord available
    eInitState := _DOHandleInvalid;
    return;
  end_if;
  
  // Reset output memory area
  _memset(pWriteData, 0, sizeof(t_s_WriteData));

  //Reset Statemachines
  eInitSSW        := Init_Variables;
  eResponseState  := SDO_idle;
  eInitState      := _NotInitialized;

END_FUNCTION


FUNCTION VIRTUAL AM441::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  
  //Call Response of Base-Class
  ret_code := SdiasBase::ReceiveSDOResponse(eCommand        := eCommand, 
                                            hOffset         := hOffset, 
                                            usLength        := usLength, 
                                            eResult         := eResult, 
                                            pResponseBuffer := pResponseBuffer, 
                                            ResponseLength  := ResponseLength);
  
  // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;   
  
  //Evaluate Result of SDO
  //----------------------------------------------------------------------------
  if eResult = READY then
    
    //Check Type of SDO-Command
    case eCommand of
    
      //Memory Write
      SDIAS_SDO_CMD_MEM_WRITE:
      
        case hOffset of
          AM441_ADDR_CFG_FIRMWARE:
            if eResponseState = SDO_wait then
              eResponseState := SDO_valid;
            end_if;
        
        else
            LogError("(AM441::ReceiveSDOResponse) Invalid Offset in Write-Response of SDO");
        end_case;
      
      //Memory Read
      SDIAS_SDO_CMD_MEM_READ:
      
        case hOffset of
        
          AM441_ADDR_STATE_FIRMWARE:
            if eResponseState = SDO_wait then
              eResponseState := SDO_valid;
            end_if;
            sFWState := pResponseBuffer^$t_s_FWState;
            
          else
            LogError("(AM441::ReceiveSDOResponse) Invalid Offset in Read-Response of SDO");
        end_case;
    end_case;

    //Check if Class was in Valid State for SDO Response    
    if eResponseState <> SDO_valid then
      LogError("(AM441::ReceiveSDOResponse) Error in response data of SDO");
      eInitSSW := Init_Error;      
    end_if;
    
  //Problem with Response
  //----------------------------------------------------------------------------    
  else
  
    //Check Type of SDO-Command to set correct Log-Message
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        LogError("(AM441::ReceiveSDOResponse) Error while executing a sdo write-command");
      SDIAS_SDO_CMD_MEM_READ:
        LogError("(AM441::ReceiveSDOResponse) Error while executing a sdo read-command");
    end_case;
    
    eInitSSW := Init_Error;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM441::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode      : iprStates;
  END_VAR
  
  eModuleInitState := BUSY;

  //*****************************************************************************
  //** STATEMACHINE FOR INITIALIZATION OF THE MODULE                           **
  //*****************************************************************************
  
  CASE eInitSSW OF
    //Setting up Variables
    //***************************************************************************
    Init_Variables:
      AI1Config := AI1Config.Read();
      AI2Config := AI2Config.Read();
      AI3Config := AI3Config.Read();
      AI4Config := AI4Config.Read();
      
      AI1_Freq := AI1_Freq.Read();
      AI2_Freq := AI2_Freq.Read();
      AI3_Freq := AI3_Freq.Read();
      AI4_Freq := AI4_Freq.Read();

      sFWConfiguration.StandardModus.uiAI1_Freq := SetFrequency(AI1_Freq);
      sFWConfiguration.StandardModus.uiAI2_Freq := SetFrequency(AI2_Freq);
      sFWConfiguration.StandardModus.uiAI3_Freq := SetFrequency(AI3_Freq);
      sFWConfiguration.StandardModus.uiAI4_Freq := SetFrequency(AI4_Freq);

      AI1_Min := AI1_Min.Read();
      AI1_Max := AI1_Max.Read();
      AI2_Min := AI2_Min.Read();
      AI2_Max := AI2_Max.Read();
      AI3_Min := AI3_Min.Read();
      AI3_Max := AI3_Max.Read();
      AI4_Min := AI4_Min.Read();
      AI4_Max := AI4_Max.Read();
      
      aAIRange[0] := AI1_Max - AI1_Min;
      aAIRange[1] := AI2_Max - AI2_Min;
      aAIRange[2] := AI3_Max - AI3_Min;
      aAIRange[3] := AI4_Max - AI4_Min;
      
      AO1_Min := AO1_Min.Read();
      AO1_Max := AO1_Max.Read();
      AO2_Min := AO2_Min.Read();
      AO2_Max := AO2_Max.Read();
      AO3_Min := AO3_Min.Read();
      AO3_Max := AO3_Max.Read();
      AO4_Min := AO4_Min.Read();
      AO4_Max := AO4_Max.Read();
        
      GetMinMaxRange(ClientMinRange:=AO1_Min, ClientMaxRange:=AO1_Max, pMinMaxValue:=#aMinMaxOutput[0]);
      GetMinMaxRange(ClientMinRange:=AO2_Min, ClientMaxRange:=AO2_Max, pMinMaxValue:=#aMinMaxOutput[1]);
      GetMinMaxRange(ClientMinRange:=AO3_Min, ClientMaxRange:=AO3_Max, pMinMaxValue:=#aMinMaxOutput[2]);
      GetMinMaxRange(ClientMinRange:=AO4_Min, ClientMaxRange:=AO4_Max, pMinMaxValue:=#aMinMaxOutput[3]);

      // set analog input mode
      sFWConfiguration.StandardModus.Ai_mode := 0;

      sFWConfiguration.StandardModus.Ai_mode.AI1_Def0_Ground1     := AI1Config <> 0;
      sFWConfiguration.StandardModus.Ai_mode.AI2_Def0_Ground1     := AI2Config <> 0;
      sFWConfiguration.StandardModus.Ai_mode.AI3_Def0_Ground1     := AI3Config <> 0;
      sFWConfiguration.StandardModus.Ai_mode.AI4_Def0_Ground1     := AI4Config <> 0;
      
      // Set the MinValue if AO is out of Range
      if (AO1_Max < AO1) | (AO1_Min > AO1) then
        AO1 := AO1_Min;
      end_if;
      if (AO2_Max < AO2) | (AO2_Min > AO2) then
        AO2 := AO2_Min;
      end_if;
      if (AO3_Max < AO3) | (AO3_Min > AO3) then
        AO3 := AO3_Min;
      end_if;
      if (AO4_Max < AO4) | (AO4_Min > AO4) then
        AO4 := AO4_Min;
      end_if;
      
      sOutputValues.AO1_2.Output1 := CalcScaleInv(AO1, AO1_Min, AO1_Max);
      sOutputValues.AO1_2.Output2 := CalcScaleInv(AO2, AO2_Min, AO2_Max);
      sOutputValues.AO3_4.Output1 := CalcScaleInv(AO3, AO3_Min, AO3_Max);
      sOutputValues.AO3_4.Output2 := CalcScaleInv(AO4, AO4_Min, AO4_Max);
      
      // for first access
      bsChangeFlag.AO1_2 := true;
      bsChangeFlag.AO3_4 := true;
 
      // set standard configuration
      sFWConfiguration.Info.PMBModus                := false;
      sFWConfiguration.Info.BootLoaderUpdateReqest  := false;    
      sFWConfiguration.uDataLength                  := sizeof(t_s_FWConfiguration) - sizeof(t_s_FWConfiguration.hCRC) - sizeof(t_s_FWConfiguration.uDataLength);
      sFWConfiguration.hCRC                         := CheckSum_16(pData:=(#sFWConfiguration.Info)$^UINT, uiDataLength:=sFWConfiguration.uDataLength, uiCrcStart:=16#FFFF);
      
      eInitSSW   := Init_Firmware;
      
    //Initialize Firmware
    //*****************************************************************************
    Init_Firmware:
    
      //Statemachine for SDO-Communication
      case eResponseState of
        //Idle
        //-------------------------------------------------------
        SDO_idle:
        
          //Start SDO-Command
          TmpRetcode  := StartWriteSDO(hOffset      :=AM441_ADDR_CFG_FIRMWARE,
                                      usLength      :=sizeof(t_s_FWConfiguration),
                                      pWriteBuffer  :=(#sFWConfiguration)$^USINT,
                                      eCommand      :=SDIAS_SDO_CMD_MEM_WRITE);
           
          //Evaluate Returncode
          if TmpRetcode = READY then
          
            //Timestamp for TimeoutCheck
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= SDO_wait;
            
          //Error occured  
          elsif TmpRetcode = ERROR then
          
            eModuleInitState := ERROR;
            LogError("(AM441::InitModule) Failed to add write SDO for firmware configuration");
            eInitState := _NoMem;
            
          end_if;
          
          
        //Wait for Response
        //-------------------------------------------------------
        SDO_wait:
        
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > AM441_SDO_RESPONSE_TIMEOUT) then
          
            LogError("(AM441::InitModule) SDO Response timeout config module");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := Init_Error;
            
          end_if;

        //Response received
        //-------------------------------------------------------
        SDO_valid:
        
          eInitSSW        := Init_GetStateFW;
          eResponseState  := SDO_idle;

      end_case;
      
    //Get Firmware Informations
    //*****************************************************************************
    Init_GetStateFW:
    
      //Statemachine for SDO-Communication
      case eResponseState of

        //Idle
        //-------------------------------------------------------      
        SDO_idle:
        
          //Start SDO-Command
          TmpRetcode  := StartReadSDO(  hOffset   :=AM441_ADDR_STATE_FIRMWARE,
                                        usLength  :=sizeof(t_s_FWState),
                                        eCommand  :=SDIAS_SDO_CMD_MEM_READ);
                                        
          //Evaluate Returncode
          if TmpRetcode = READY then
          
            //Timestamp for TimeoutCheck
            udSDOTimeout      := ops.tAbsolute;
            eResponseState := SDO_wait;
           
          //Error occured 
          elsif TmpRetcode = ERROR then
          
            eModuleInitState := ERROR;
            LogError("(AM441::InitModule) Failed to add read SDO for firmware info");
            eInitState := _NoMem;
            
          end_if; 

        //Wait for Response
        //-------------------------------------------------------
        SDO_wait:
          
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > AM441_SDO_RESPONSE_TIMEOUT) then
          
            LogError("(AM441::InitModule) SDO Response timeout read state");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := Init_Error;
            
          end_if;
          
        //Response received
        //-------------------------------------------------------
        SDO_valid:
        
          //Check Length of FirmwarePackage
          if sFWState.uDataLength = (sizeof(t_s_FWState) - sizeof(t_s_FWState.hCRC) - sizeof(t_s_FWState.uDataLength)) then
          
            //Check CRC
            if (sFWState.hCRC = CheckSum_16(pData:= #sFWState.hFWVersion,
                                            uiDataLength:= sFWState.uDataLength,
                                            uiCrcStart:=16#FFFF)) then
              
              //Write Version of FW to Server
              FirmwareVersion := (sFWState.hFWVersion and 16#0000FFFF)$HDINT;
              
              //next step
              eInitSSW         := Init_Finish;
              eResponseState   := SDO_idle;
              
            // Wrong CRC
            else
            
              eModuleInitState := ERROR;
              LogError("(AM441::InitModule) Invalid checksum at firmware info");
              eInitState := _ClientNotready;
              
            end_if;
            
          //Wrong Data-Length
          else
          
              eModuleInitState := ERROR;
              LogError("(AM441::InitModule) Invalid length at firmware info");
              eInitState := _ClientNotready;
              
          end_if;

      end_case;

    //Initialization of Module finished
    //*****************************************************************************
    Init_Finish:
    
      eInitSSW         := Init_Variables;
      eModuleInitState := READY;
      eInitState      := _ClassOk;
      
   //Error during Initialization
   //*****************************************************************************
    Init_Error:
    
      eModuleInitState := ERROR;
      
      // Keep _InvalidConfiguration for eInitState
      if (eInitState <> _InvalidConfguration) then
        eInitState      := _ClientNotready;
      end_if;  
      

  END_CASE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM441::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  
	//look if it is right hardware
	if ( udID2Check <> DEVICE_ID_AM441 ) then
		bIsOK := FALSE;
	else
    bIsOK := TRUE;
	end_if;
  
END_FUNCTION

FUNCTION AM441::SetFrequency
	VAR_INPUT
		ClientValue 	: UDINT;
	END_VAR
	VAR_OUTPUT
		Frequency 	: UINT;
	END_VAR
  
  // lookup table for cut off frequency
  case ClientValue of
    6:  Frequency := 10;
    5:  Frequency := 25;
    4:  Frequency := 50;
    3:  Frequency := 100;
    2:  Frequency := 250;
    1:  Frequency := 500;
  else 
        Frequency := 1000;
  end_case;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM441::DisconnectEvent
  
  //Reset DO-Data
  if pWriteData then
    _memset(dest := pWriteData, usByte := 0, cntr := sizeof(t_s_WriteData));
  end_if;

  //Call Disconnect of Base-Class
  SdiasBase::DisconnectEvent();

END_FUNCTION


FUNCTION AM441::AM441
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  
	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM441::AO1::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // Only react to changing Values
  if AO1 <> input then  
    // Check input borders
    if input > aMinMaxOutput[0].MaxRangeValue then
      input := aMinMaxOutput[0].MaxRangeValue;
    end_if;
    if input < aMinMaxOutput[0].MinRangeValue then
      input := aMinMaxOutput[0].MinRangeValue;
    end_if;
  
    AO1 := input;    
    
    // Convert Scaled Server Value to corresponding binary value (value sent to the module)
    sOutputValues.AO1_2.Output1 := CalcScaleInv(AO1, AO1_Min, AO1_Max);
    
    bsChangeFlag.AO1_2 := 1; 
    result := AO1;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM441::AO2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // Only react to changing Values
  if AO2 <> input then  
    // Check input borders
    if input > aMinMaxOutput[1].MaxRangeValue then
      input := aMinMaxOutput[1].MaxRangeValue;
    end_if;
    if input < aMinMaxOutput[1].MinRangeValue then
      input := aMinMaxOutput[1].MinRangeValue;
    end_if;
  
    AO2 := input;    
    
    // Convert Scaled Server Value to corresponding binary value (value sent to the module)
    sOutputValues.AO1_2.Output2 := CalcScaleInv(AO2, AO2_Min, AO2_Max);
    
    bsChangeFlag.AO1_2 := 1; 
    result := AO2;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM441::AO3::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // Only react to changing Values
  if AO3 <> input then  
    // Check input borders
    if input > aMinMaxOutput[2].MaxRangeValue then
      input := aMinMaxOutput[2].MaxRangeValue;
    end_if;
    if input < aMinMaxOutput[2].MinRangeValue then
      input := aMinMaxOutput[2].MinRangeValue;
    end_if;
  
    AO3 := input;    
    
    // Convert Scaled Server Value to corresponding binary value (value sent to the module)
    sOutputValues.AO3_4.Output1 := CalcScaleInv(AO3, AO3_Min, AO3_Max);
    
    bsChangeFlag.AO3_4 := 1; 
    result := AO3;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM441::AO4::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // Only react to changing Values
  if AO4 <> input then  
    // Check input borders
    if input > aMinMaxOutput[3].MaxRangeValue then
      input := aMinMaxOutput[3].MaxRangeValue;
    end_if;
    if input < aMinMaxOutput[3].MinRangeValue then
      input := aMinMaxOutput[3].MinRangeValue;
    end_if;
  
    AO4 := input;    
    
    // Convert Scaled Server Value to corresponding binary value (value sent to the module)
    sOutputValues.AO3_4.Output2 := CalcScaleInv(AO4, AO4_Min, AO4_Max);
    
    bsChangeFlag.AO3_4 := 1; 
    result := AO4;
  end_if;

END_FUNCTION


FUNCTION AM441::CalcScaleInv
	VAR_INPUT
		ScaleVal 	: DINT;
		MinVal 	: DINT;
		MaxVal 	: DINT;
	END_VAR
	VAR_OUTPUT
		BinVal 	: INT;
	END_VAR
  
  // Convert Scaled Value to corresponding binary value
  BinVal := (AM441_FIRMWARE_MIN + ((AM441_FIRMWARE_MAX - AM441_FIRMWARE_MIN) * (ScaleVal - MinVal)) / (MaxVal - MinVal))$INT;

END_FUNCTION


FUNCTION VIRTUAL AM441::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR

  TaskCfg := SDIAS_TASK_MASK_RT_PRE OR SDIAS_TASK_MASK_RT_POST;

END_FUNCTION


FUNCTION VIRTUAL AM441::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR

  output := DEVICE_ID_AM441;

END_FUNCTION


FUNCTION VIRTUAL AM441::GetFWVersion
	VAR_INPUT
		pData 	: ^CHAR;
		Length 	: UDINT;
	END_VAR
  
  //Check pointer
  if pData then
    //Length of Firmwareversion (HDINT) -> 8Byte +1 byte zero termination
    if Length >= 9 then
      _itoa(udNumber:=FirmwareVersion, pString:=pData);  
    else
      pData^ := 0;
    end_if; 
  end_if;
  
END_FUNCTION


FUNCTION AM441::GetMinMaxRange
	VAR_INPUT
		ClientMinRange 	: DINT;
		ClientMaxRange 	: DINT;
		pMinMaxValue 	  : ^t_MinMaxRange;
	END_VAR
  
  if ClientMinRange < ClientMaxRange then
    pMinMaxValue^.MinRangeValue := ClientMinRange;
    pMinMaxValue^.MaxRangeValue := ClientMaxRange;
  else    
    pMinMaxValue^.MinRangeValue := ClientMaxRange;
    pMinMaxValue^.MaxRangeValue := ClientMinRange;
  end_if;

END_FUNCTION