//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\HwControl\HwControl.h"
#include "..\..\Class\HwControl\watchdog.h"

(*!
<Class
	Name               = "HwControl"
	Revision           = "4.2"
	GUID               = "{4794F3F9-7ABA-4680-9933-0608225B5265}"
	RealtimeTask       = "true"
	DefRealtime        = "1 ms"
	DefRealtimeIndex   = "0"
	CyclicTask         = "true"
	DefCyclictime      = "1 ms"
	DefCyclicIndex     = "2147483392"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\HwControl\HwControl.ico"
	SharedCommandTable = "true"
	Objectsize         = "(646,120)"
	Comment            = "Class to handle VaranManager and the cooperation with DiasMasterC">
	<Channels>
		<Server Name="Control">
		</Server>
		<Server Name="DiasMaster" WriteProtected="false" Comment="connect to client &apos;to_HWControl&quot; of class DiasMasterC if used (if Server is 1 class is connected)&#13;&#10;">
		</Server>
		<Server Name="SafetyState" GUID="{7E088AB6-AB0A-450E-964A-E46FE15A0D4B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows state of safety functionality initialisation&#13;&#10;&#13;&#10; 1..OK&#13;&#10; 0..not active or initializing&#13;&#10;-1..failed to allocate memory&#13;&#10;-2..invalid domain number set in this system&#13;&#10;-3..newer OS version required for domain number support&#13;&#10;-4..method to determine domain number not provided by lsl_st_hardwaretree.h&#13;&#10;-5..only 1 instance of safety manager allowed&#13;&#10;-6..a slave system can only have 1 master. check hw class configuration&#13;&#10;-7..invalid module type tried to log in&#13;&#10;-8..couldn&apos;t find InterfaceCRC which is requested by other domain. Check SafetyDesigner projects, most likely the interface variables doesn&apos;t match.&#13;&#10;-9..failed to add a new copy data object to varan manager&#13;&#10;-10..a non-optional module or domain is not available&#13;&#10;-11..timeout in initialisation (see debugger trace or logfile for further details)"/>
		<Client Name="HWRtPostScan" Required="true" Internal="true"/>
		<Client Name="SafetyDomainTimeout" Required="false" Internal="false" Comment="[ms] the class has to wait for optional interface domains (leave 0 if none available)"/>
		<Client Name="SafetyManager" Required="true" Internal="true"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\LSL_STITask.h" Include="false"/>
			<File Path=".\Class\VaranManager_Base\VaranManager_Base.h" Include="false"/>
			<File Path=".\Class\HwControl\HwControl.h" Include="true"/>
			<File Path=".\Class\HwControl\watchdog.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="renste"/>
		<Dokumentation Revision="4.2" Date="06.06.2016" Author="EisMic" Company="Sigmatek" Description="Corrected error if distributed safety modules are connected after the initialisation phase."/>
		<Dokumentation Revision="4.1" Date="11.05.2016" Author="RamAnd" Company="Sigmatek" Description="Suppressed warning that would occur with target ARM on compiler version 30 or higher."/>
		<Dokumentation Revision="4.0" Date="30.11.2015" Author="ZoePat&#13;&#10;LanSte" Company="Sigmatek" Description="Check for unallowed safety topology."/>
		<Dokumentation Revision="3.9" Date="21.10.2015" Author="RamAnd" Company="Sigmatek" Description="Support for MS012 added"/>
		<Dokumentation Revision="3.8" Date="19.05.2015" Author="RamAnd" Company="Sigmatek" Description="If two systems with FSoE safety were connected via VBC/VMC an error in the connection establishment could cause the FSoE connection to fail."/>
		<Dokumentation Revision="3.7" Date="15.04.2015" Author="RamAnd" Company="Sigmatek" Description="Added another step in initialisation to prevent watchdog error."/>
		<Dokumentation Revision="3.6" Date="16.10.2014&#13;&#10;25.03.2015" Author="RamAnd&#13;&#10;PieSte" Company="Sigmatek" Description="Support for SCP111 added.&#13;&#10;Support for SDD1300, SDD1400, SDD1500 and SDD1600 added."/>
		<Dokumentation Revision="3.5" Date="12.11.2014" Author="PieSte" Company="Sigmatek" Description="Removed trace message if watchdog interface is not available."/>
		<Dokumentation Revision="3.4" Date="28.10.2014" Author="RamAnd" Company="Sigmatek" Description="If an error has been reported to HwControl, it is now forwarded to the DiasMasterC object (if there is one)."/>
		<Dokumentation Revision="3.3" Date="10.10.2014" Author="PieSte" Company="Sigmatek" Description="Added Watchdog API and trigger watchdog in postscan task."/>
		<Dokumentation Revision="3.2" Date="18.06.2014" Author="EisMic" Company="Sigmatek" Description="Added support for reading hardware diagnosis via newinst cmd: CMD_GET_HARDWARE_DIAGNOSE "/>
		<Dokumentation Revision="3.1" Date="17.06.2014" Author="RamAnd" Company="Sigmatek" Description="Added possibility to start a quit error via OS interface."/>
		<Dokumentation Revision="3.0" Date="15.04.2014" Author="RamAnd" Company="Sigmatek" Description="Changed initialisation: &#13;&#10; - Activation of hardware classes realtime task as well as completing CDIAS/DIAS initialisation is now done in post init instead of last init&#13;&#10; - No realtime is running in the first initialisation of the modules&#13;&#10; - New second initialisation where realtime is running to check if the realtime data are valid"/>
		<Dokumentation Revision="2.0" Date="12.02.2014" Author="PieSte" Company="Sigmatek" Description="Improved description of CyWork method."/>
		<Dokumentation Revision="1.50" Date="06.12.2013" Author="LanSte&#13;&#10;RamAnd&#13;&#10;FucHer" Company="Sigmatek" Description="Ensured that he class is copatible with old loader versions that do not support the post init phase.&#13;&#10;Removed domain support&#13;&#10;Changed AWL code to Structured Text.&#13;&#10;If the task setting for cyclic task fails, the error wasn&apos;t displayed.&#13;&#10;The task setting for cyclic task didn&apos;t work (only required if existing object is updated)."/>
		<Dokumentation Revision="1.40" Date="01.08.2013" Author="RamAnd" Company="Sigmatek" Description="Corrected error, where the user classes are already called during SDIAS initialisation."/>
		<Dokumentation Revision="1.30" Date="18.07.2013" Author="RamAnd" Company="Sigmatek" Description="Added PostInit interface of loader, where after the last init the varan managers can initialize modules until they are ready."/>
		<Dokumentation Revision="1.20" Date="07.03.2013" Author="RamAnd" Company="Sigmatek" Description="Changed range of the safety NewInst commands. Range for HW-Classes: 0x8000-0x8FFF; Range for Safety HW-Classes: 0x8100-0x81FF"/>
		<Dokumentation Revision="1.15" Date="23.12.2011" Author="RamAnd" Company="Sigmatek" Description="Added support for the SafetyManager"/>
		<Dokumentation Revision="1.14" Date="14.02.2012" Author="RamAnd" Company="Sigmatek" Description="Watchdog is now also triggered if no VARAN/DIAS interface is available (needed for internal IOs of Edge ETVs)"/>
		<Dokumentation Revision="1.13" Date="25.05.2011" Author="RamAnd" Company="Sigmatek" Description="PostScan-Calls in Init-Phase are now done in HwControl instead of VaranManager."/>
		<Dokumentation Revision="1.12" Date="27.10.2010" Author="RamAnd" Company="Sigmatek" Description="Added RtPostScan support for special hardware like the IOs of an Edge ETV"/>
		<Dokumentation Revision="1.11" Date="13.08.2010" Author="BleErn" Company="Sigmatek" Description="Postscan calls were not stopped on error"/>
		<Dokumentation Revision="1.10" Date="22.07.2010" Author="WocPet" Company="Sigmatek" Description="New functionality added to display required error from diasmaster"/>
		<Dokumentation Revision="1.9" Date="13.07.2010" Author="BleErn" Company="Sigmatek" Description="Content of corresponding LASAL Hardware Description file (.lhd) which is necessary for the hardware editor has been corrected"/>
		<Dokumentation Revision="1.8" Date="03.03.2010" Author="BleErn" Company="Sigmatek" Description="Added Handling for DiasMaster RtPostScan"/>
		<Dokumentation Revision="1.7" Date="08.02.2010" Author="BleErn" Company="Sigmatek" Description="Added Baseclass for RtPostScan with DIAS/CDIAS/CTMS&#13;&#10;Caution: RtPostScan cannot be used together with RtDebug!"/>
		<Dokumentation Revision="1.6" Date="10.03.2010" Author="RamAnd" Company="Sigmatek" Description="Added Support for various IOs (e.g. ETV Edge IOs)"/>
		<Dokumentation Revision="1.5" Date="03.02.2009" Author="RamAnd" Company="Sigmatek" Description="Added Synchronity check if VMC is used."/>
	</RevDoku>
	<Network Name="HwControl">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{4EF772E0-592A-4829-B661-2E7E0E1B8913}"
				Class      = "HwControlBase"
				Position   = "(218,120)"
				Visualized = "false"
				RealTime   = "1 ms">
				<Channels>
					<Server Name="Control"/>
					<Server Name="DiasMaster"/>
					<Server Name="State"/>
					<Client Name="RtDebug"/>
					<Client Name="To_StdLib"/>
					<Client Name="To_TaskObjectControl"/>
				</Channels>
			</Object>
			<Object
				Name       = "HWRtPostScan"
				GUID       = "{367B4BFF-6F56-4D89-B858-79BEE0B86711}"
				Class      = "HWRtPostScan"
				Position   = "(210,420)"
				Visualized = "false"
				RealTime   = "1 ms"
				RealIndex  = "1073741824">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="toHwControlBase"/>
				</Channels>
			</Object>
			<Object
				Name       = "SafetyManager"
				GUID       = "{4545C840-4FB2-4C80-B150-345DF08208A7}"
				Class      = "SafetyManager"
				Position   = "(990,420)"
				Visualized = "true"
				CyclicTime = "10 ms">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="LoginCnt"/>
					<Server Name="MaxSyncDuration"/>
					<Server Name="MinSyncDuration"/>
					<Server Name="SyncDuration"/>
					<Client Name="SafetyDomainTimeout"/>
					<Client Name="To_HwControl"/>
					<Client Name="To_OSKernel"/>
					<Client Name="To_StdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Control" Destination="_base.Control" Vertices="(1824,210),(886,210),"/>
			<Connection Source="this.State" Destination="_base.State" Vertices="(1824,270),(886,270),"/>
			<Connection Source="this.DiasMaster" Destination="_base.DiasMaster" Vertices="(1824,330),(886,330),"/>
			<Connection Source="_base.RtDebug" Destination="this.RtDebug" Vertices="(218,330),(120,330),(120,210),(38,210),"/>
			<Connection Source="this.HWRtPostScan" Destination="HWRtPostScan.ClassSvr"/>
			<Connection Source="HWRtPostScan.toHwControlBase" Destination="_base.Control" Vertices="(210,510),(150,510),(150,390),(930,390),(930,210),(886,210),"/>
			<Connection Source="this.SafetyManager" Destination="SafetyManager.ClassState"/>
			<Connection Source="SafetyManager.To_HwControl" Destination="_base.Control" Vertices="(990,510),(930,510),(930,210),(886,210),"/>
			<Connection Source="this.SafetyState" Destination="SafetyManager.ClassState" Vertices="(1824,390),(1740,390),(1740,510),(1652,510),"/>
			<Connection Source="SafetyManager.SafetyDomainTimeout" Destination="this.SafetyDomainTimeout" Vertices="(990,690),(120,630),(120,390),(38,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using HwControlBase

HwControl : CLASS
: HwControlBase
	TYPE
	  pVaranManager : ^VaranManager;
	  t_DMFunctions : STRUCT
	    p_RtFunction : pVoid;
	    p_SendSync : pVoid;
	    p_FinishIMProg : pVoid;
	    p_LastInit : pVoid;
	    p_This : pVoid;
	    sd_PllTime : DINT;
	    ud_DiasTime : UDINT;
	    sd_RtDebug : DINT;
	    p_RtPostScanFunction : pVoid;
	    SafetyManagerThisPointer : ^pVirtualBase;
	  END_STRUCT;
	  t_DiasMaster : STRUCT
	    ud_Counter : UDINT;
	    p_Functions : ^t_DMFunctions;
	  END_STRUCT;
#pragma pack(push, 1)
	  t_HwObjectListElement : STRUCT
	    pThis : pVirtualBase;
	    pRtPostScan : ^UDINT;  //! <Type Comment="used for EdgeETV IOs" Name="t_HwObjectListElement.pRtPostScan"/>
	    bdSettings : t_HwObjListSettings;
	    usEscSequence : USINT;  //! <Type Comment="Escapesequence that identifies the bustype." Name="t_HwObjectListElement.usEscSequence"/>
	    pNext : ^t_HwObjectListElement;
	  END_STRUCT;
#pragma pack(pop)
	  t_VMFunctions : STRUCT
	    p_This : pVaranManager;
	    ud_VaranTime : UDINT;
	    b_IsAlsoClient : BOOL;
	    ud_SuperiorTime : UDINT;
	    b_HWClassSynchron : BOOL;
	    b_OverrideFrameCheck : BOOL;
	    SafetyManagerThisPointer : ^pVirtualBase;
	    Reserved1 : DINT;
	    Reserved2 : DINT;
	  END_STRUCT;
	  t_OneVaranManager : STRUCT
	    ud_Counter : UDINT;
	    ud_SuperiorSync : UDINT;
	    ud_SuperiorSyncActual : UDINT;
	    p_Functions : ^t_VMFunctions;
	  END_STRUCT;
	END_TYPE
  //Servers:
	SafetyState 	: SvrCh_DINT;
  //Clients:
	HWRtPostScan 	: CltChCmd_HWRtPostScan;
	SafetyManager 	: CltChCmd_SafetyManager;
	SafetyDomainTimeout 	: CltCh_UDINT;
  //Variables:
		ud_MyRtTaskTime 	: UDINT;			//! <Variable Comment="tasktime of HwControl realtime task" Name="ud_MyRtTaskTime"/>
		ud_MyCyTaskTime 	: UDINT;			//! <Variable Comment="tasktime of HwControl cyclic task" Name="ud_MyCyTaskTime"/>
		a_VaranManager : ARRAY [0..MAX_VARAN_MANAGERS-1] OF t_OneVaranManager;
			//! <Variable Comment="array of structures for VaranManager functions and settings" Name="a_VaranManager"/>
		s_DiasMaster 	: t_DiasMaster;			//! <Variable Comment="structure for DiasMaster functions and settings" Name="s_DiasMaster"/>
		us_Initcounter 	: USINT;			//! <Variable Comment="varaiable to count init steps" Name="us_Initcounter"/>
		p_DebugAPI 	: ^DEBUGAPI;			//! <Variable Comment="pointer to debug API (OS - Interface)" Name="p_DebugAPI"/>
		p_WatchdogAPI 	: ^LSLAPI_IWATCHDOG;
		SyncCheck 	: USINT;
		Old 	: USINT;
		Act 	: USINT;
		pSpecialObjects 	: ^t_HwObjectListElement;
		b_PostScanStarted 	: DINT;
		ud_FirstPostScanCall 	: UDINT;
		ud_LastPostScanWorkCall 	: UDINT;
		bVaranManagerAvailable 	: BOOL;
		pSCDW 	: ^LSL_CDIASWATCHDOG;
		pHwControlLogins 	: ^t_HwObjectListElement;
		b_PostInitInstalled 	: BOOL;
  //Functions:
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Init for HwControl class&#13;&#10;=================================================================================================&#13;&#10;[clients] RtDebug    :R&#13;&#10;[members] us_InitCounter  :R/W :varaiable to count init steps&#13;&#10;   p_DebugAPI   :W  :pointer to debug API (OS - Interface)&#13;&#10;   s_DiasMaster  :R  :structure for DiasMaster functions and settings&#13;&#10;" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="This function is used to handle CyWork of connected classes" Name="CyWork"/>
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Rt Work of HwControl (to handle all hardware classes)&#13;&#10;=================================================================================================&#13;&#10;[server] State    :R  :server shows error state of HwControl class&#13;&#10;[members] s_DiasMaster  :R  :structure for DiasMaster functions and settings&#13;&#10;   a_VaranManager  :R  :array of structures for VaranMaster functions and settings&#13;&#10;   sd_MyTaskTime  :R  :tasktime of HwControl realtime task&#13;&#10;" Name="RtWork"/>
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
	
	FUNCTION VIRTUAL GLOBAL AddSafetyManager
		VAR_INPUT
			pThis 	: pVirtualBase;
		END_VAR
		VAR_OUTPUT
			pFirstVM 	: pVirtualBase;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DisableSafetyManager;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Class to call a function pointer&#13;&#10;=================================================================================================&#13;&#10;" Name="CallPtr"/>
	FUNCTION CallPtr
		VAR_INPUT
			p_function 	: pVoid;			//! <Variable Comment="pointer to function should be called" Name="CallPtr.p_function"/>
			p_this 	: pVoid;			//! <Variable Comment="thispointer of object" Name="CallPtr.p_this"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to get Tasktime of Hwcontrol class&#13;&#10;=================================================================================================&#13;&#10;[members] sd_MyTaskTime  :R/W :variable for out tasktime of realtime task&#13;&#10;[locals] s_objinfo   :W/R :variable for objectinfo&#13;&#10;" Name="GetMyTaskTime"/>
	FUNCTION GLOBAL GetMyTaskTime
		VAR_OUTPUT
			ud_task_time 	: UDINT;			//! <Variable Comment="rt task time in us" Name="GetMyTaskTime.ud_task_time"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a VaranMaster to HwControl list&#13;&#10;=================================================================================================&#13;&#10;[server] State    :W  :server shows error state of HwControl class&#13;&#10;[members] a_VaranManager  :W  :array of structures for VaranMaster functions and settings&#13;&#10;[&gt;ud_master_number]number of varan master&#13;&#10;" Name="AddVaranManager"/>
	FUNCTION GLOBAL AddVaranManager
		VAR_INPUT
			ud_manager_number 	: UDINT;
			p_function_list 	: ^void;			//! <Variable Comment="pointer to function list and settings of VaranMaster" Name="AddVaranManager.p_function_list"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function sets Hardware off&#13;&#10;=================================================================================================&#13;&#10;[server] State   :W  :server shows error state of HwControl class&#13;&#10;" Name="SetHardwareOff"/>
	FUNCTION GLOBAL SetHardwareOff
		VAR_INPUT
			e_error 	: t_e_VaranErrors;			//! <Variable Comment="reason why hardware is set off" Name="SetHardwareOff.e_error"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function returns Debug State&#13;&#10;=================================================================================================&#13;&#10;" Name="GetRtDebugState"/>
	FUNCTION GLOBAL GetRtDebugState
		VAR_OUTPUT
			sd_RtDebug 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL AddSpecialHW
		VAR_INPUT
			pThis 	: pVirtualBase;
			pRtPostScan 	: ^UDINT;			//! <Variable Comment="pointer on method to call in RtPostScan" Name="AddSpecialHW.pRtPostScan"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION PostScanWork;
	
	FUNCTION AWL CallPtr_AWL
		VAR_INPUT
			p_function 	: DINT;
			p_this 	: DINT;
		END_VAR;
				//! <Function Comment="This function prototype is used to call functions via function pointers." Name="ObjectFunct"/>
	FUNCTION ObjectFunct;
	
	FUNCTION InstallPostInitCB
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL AddHwObject
		VAR_INPUT
			pThis 	: pVirtualBase;
			Settings 	: t_HwObjListSettings;
			EscapeSequence 	: USINT := 0;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Control::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Write Function of DiasMaster&#13;&#10;=================================================================================================&#13;&#10;[server] State    :W  :server shows error state of HwControl class&#13;&#10;   DiasMaster   :W  :server which is connected to DiasMaster&#13;&#10;[members] s_DiasMaster  :W  :pointer to DiasMaster functions and settings&#13;&#10;" Name="DiasMaster.Write"/>
	FUNCTION VIRTUAL GLOBAL DiasMaster::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SafetyState::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using HWRtPostScan
#pragma using SafetyManager


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB HwControl::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_HWCONTROL
4$UINT, 2$UINT, (SIZEOF(::HwControl))$UINT, 
1$UINT, 3$UINT, 0$UINT, 
TO_UDINT(2471641665), "HwControl", //Class
TO_UDINT(1193052171), "HwControlBase", 1$UINT, 10$UINT, //Baseclass
//Servers:
(::HwControl.SafetyState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1504224158), "SafetyState", 
//Clients:
(::HwControl.HWRtPostScan.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4260294091), "HWRtPostScan", TO_UDINT(4260294091), "HWRtPostScan", 1$UINT, 0$UINT, 
(::HwControl.SafetyManager.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1799751072), "SafetyManager", TO_UDINT(1799751072), "SafetyManager", 2$UINT, 2$UINT, 
(::HwControl.SafetyDomainTimeout.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(1863305286), "SafetyDomainTimeout", 
END_FUNCTION


#define USER_CNT_HwControl 3

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_HwControl] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION HwControl::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= HwControlBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= HwControlBase::Control.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, HwControlBase::Control.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_HwControl;
	vmt.CmdTable.NewInstr		:= #Control::NewInst();
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	vmt.CmdTable.RtWork		:= #RtWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #AddSafetyManager();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #DisableSafetyManager();

#pragma warning (default : 74)
	HwControlBase::Control.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF HwControlBase::Control.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DiasMaster.pMeth			:= StoreMethod( #M_RD_DIRECT(), #DiasMaster::Write() );
	IF DiasMaster.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SafetyState.pMeth			:= StoreMethod( #SafetyState::Read(), #M_NO_F() );
	IF SafetyState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

#pragma usingLtd VaranManager

//{{LSL_IMPLEMENTATION
#pragma using VaranManager_Base
#pragma using VaranManager

#include <lsl_st_xtimer.h>

// Method define because we need poiner to method
FUNCTION GLOBAL LDR_InstallPostInitCB
VAR_INPUT
  pThis : ^VirtualBase;
  pCmdSvr : ^SVRCHCMD;
  newInstCmd : UINT;
END_VAR;


(************************************************************************************
*
*	Class controlls timing of DiasMaster and VaranMaster (later for more VaranMasters)
*	Created : Sigmatek	/	SR	/	March-April 2006
*	Changes : 
*
*
*   FOR NEWER CHANGES SEE REVISION DOCUMENTATION OF CLASS
*
*
*		1.3 => 1.4 	/   30.06.2008 
*           - [DB 884]: prevent exception in method DiasMaster::Write
*		1.2 => 1.3  /   21.03.2008
*			- [DB 817]: set RtDebug-Flag in DiasMaster
*		1.1 => 1.2	/	29.02.2008
*			- [DB 770]:	add function to get Rt-Debug State
*		1.0 => 1.1	/	28.11.2006
*			first library version
*		0.2 => 1.0	/	09.10.2006
*			initial version
*		0.1 => 0.2	/	13.06.2006
*			second testversion 
*		0.0	=> 0.1	/	10.04.2006
*			first testversion for fair in Hannover
*
************************************************************************************)
//**********************************************
//** Global variables                         **
//**********************************************
//#WP001 start
#ifdef DiasMasterC_Profiler
  VAR_GLOBAL

    HWC_Time_RTPostscan		: STRUCT
        _min 	: udint;
        _max 	: udint;
        avg 	: udint;
        run 	: udint;
        sum 	: udint;
        start : udint;
        stop 	: udint;
        diff 	: udint;
        init	: udint;
        initfl	: bool;

    END_STRUCT;
  END_VAR
#endif
//#WP001 end

//[#ENGLISH]
//=================================================================================================
//Init for HwControl class
//=================================================================================================
//[clients] RtDebug				:R
//[members] us_InitCounter		:R/W	:varaiable to count init steps
//			p_DebugAPI			:W		:pointer to debug API (OS - Interface)
//			s_DiasMaster		:R		:structure for DiasMaster functions and settings
FUNCTION VIRTUAL GLOBAL HwControl::Init
  VAR
    objInfo : LSLOBJ_INFO;    
    MyPara : CmdStruct;
    MyResult : results;
  END_VAR

  //-------------------------------------------------------------------------------------------------------------
  //First Init - phase
  if ( us_InitCounter = 0 ) then    

    GetMyTaskTime();

    //set this pointer to Rt-Debug function
    if ( OS_CILGet( "DEBUGAPI", #p_DebugAPI ) = SYS_ERR_NONE ) then
      
      //look if realtime debug option is used (our Rt-task is running even if realtime of user is debugged)
      RtDebug := RtDebug.read();
      if ( RtDebug ) then
        //save thispointer of object in OS-function
        SaveThisPointer( this, 0 );
      else
        //save NIL-Pointer to OS-function because only HwControl is allowed to use this function
        SaveThisPointer( NIL, 0 );
      end_if;
    end_if;		
     //get cil interface to trigger watchdog
    if ( OS_CILGet( INTERFACE_WATCHDOG, #p_WatchdogAPI ) <> SYS_ERR_NONE ) then
//      TRACE("ERROR: WatchdogAPI Interface not available! Newer OS is needed.");
    end_if;
  end_if; 

  //-------------------------------------------------------------------------------------------------------------
  //in last init phase we call DiasMaster init functions, bring our realtime task to first position and start it
  if ( _Firstscan = TRUE ) then
  
    // tell the loader that we need a post init phase
    InstallPostInitCB();

    IF GetRtDebugState() = 0 THEN
      // Synchronize calls of Rt & RtPostScan (same timebase) 
      To_TaskObjectControl.GetObjectInfo(thispointer:=this$^void, tasktype:=OBJ_RT, objinfo:=#objInfo);
      To_TaskObjectControl.ChangeObjectState(thispointer:=#HWRtPostScan.ClassSvr$void, actioncmd:=ACTION_NEWTIME, tasktype:=OBJ_RT, debugobj:=0, newtime:=objInfo.orgperiod);
    ELSE
      // Set RtPostScan off if RtDebug is used!
      To_TaskObjectControl.ChangeObjectState(thispointer:=#HWRtPostScan.ClassSvr$void, actioncmd:=ACTION_SUSPEND, tasktype:=OBJ_RT, debugobj:=0, newtime:=0);      
      TRACE("RtDebug is used - RtPostScan is not possible together with RtDebug!");
    END_IF;

    //look if DiasMaster is also used
    if ( s_DiasMaster.p_Functions <> NIL ) then
      
      //make some initialization in DiasMaster before we can start our realtime task
      CallPtr	( p_function	:= s_DiasMaster.p_Functions^.p_FinishIMProg
          , p_this		:= s_DiasMaster.p_Functions^.p_This
          );
    end_if;

    // if there is no post init => we have to start the realtime from here
    if b_PostInitInstalled = FALSE then
    
      // Call own NewInst with CMD_POST_INIT_CALL. For sorting VaranDOs, starting RT task, init diasmaster")      
      MyPara.uiCmd := CMD_POST_INIT_CALL;
      Control.NewInst(pPara:=#MyPara, pResult:=#MyResult);      

    end_if;

    // if there is no varan manager and no diasmaster => we have to trigger the CDIAS watchdog for internal IOs (ETV Edge)
    if bVaranManagerAvailable = FALSE & s_DiasMaster.p_Functions = NIL then
      OS_CILGET( "CDIASWATCHDOG", #pSCDW );
    end_if;
    
  end_if;
  
  us_InitCounter += 1;		//increment init phase counter

//-------------------------------------Profiler Start----------------------------------------------
  //#WP001 start
  #ifdef DiasMasterC_Profiler	
    HWC_Time_RTPostscan.sum 	:= 0;
    HWC_Time_RTPostscan.run 	:= 0;
    HWC_Time_RTPostscan._max 	:= 0;
    HWC_Time_RTPostscan._min 	:= 16#ffffffff;
    HWC_Time_RTPostscan.init  := OS_readmicrosec();
  #endif
  //#WP001 end
//-------------------------------------Profiler End------------------------------------------------

END_FUNCTION //VIRTUAL GLOBAL HwControl::Init
//[#ENGLISH]
//=================================================================================================
//Rt Work of HwControl (to handle all hardware classes)
//=================================================================================================
//[server]	State				:R		:server shows error state of HwControl class
//[members] s_DiasMaster		:R		:structure for DiasMaster functions and settings
//			a_VaranManager		:R		:array of structures for VaranMaster functions and settings
//			ud_MyTaskTime		:R		:tasktime of HwControl realtime task
FUNCTION VIRTUAL GLOBAL HwControl::RtWork
  VAR_INPUT
    EAX		: UDINT;
  END_VAR
  VAR_OUTPUT
    state		: UDINT;
  END_VAR
  VAR
    i			: DINT;
    pOneManager : ^t_OneVaranManager;
    pHelp : ^t_HwObjectListElement;
  END_VAR

  //if class is ok
  if ( HwControl::State = _ClassOk ) then

    // trigger watchdog (pointer only valid if no varan manager and diasmaster available)
    if pSCDW 
    & (p_WatchdogAPI = Nil) then
      SCDW_CDWTRIGGER();
    end_if;

    //--------------------------------------------------------------------------
    //Send Sync for DiasMaster
    if ( s_DiasMaster.p_Functions <> NIL ) then
    
      //if call time for dias master is reached
      if ( s_DiasMaster.ud_Counter = s_DiasMaster.p_Functions^.ud_DiasTime ) then

        CallPtr	( p_function	:= s_DiasMaster.p_Functions^.p_SendSync
            , p_this		:= s_DiasMaster.p_Functions^.p_This
            );
      end_if;
    end_if;

    //--------------------------------------------------------------------------
    //update realtime functions
    //of all VaranMaster
    pOneManager := #a_VaranManager[0];  // RamAnd: using pointers instead of array accesses reduces compiled awl-code by 120 lines!!!
    for i := 0 to ( MAX_VARAN_MANAGERS - 1 ) do
  
      //look if we have a correct pointer
      if ( pOneManager^.p_Functions$^INT <> NIL ) then

        // if VMC is used, then check if the framecounter has been increased => right time to call Varan HW-Classes
        if (pOneManager^.p_Functions^.b_IsAlsoClient & (pOneManager^.p_Functions^.b_OverrideFrameCheck = FALSE) & 
            pOneManager^.p_Functions^.p_This^.FrameCounterChanged(#Old, #Act)) then

          // maybe we got some phase shift
          if (pOneManager^.ud_SuperiorSyncActual <> pOneManager^.ud_SuperiorSync) &
             (pOneManager^.ud_SuperiorSyncActual MOD pOneManager^.ud_SuperiorSync) then
             
            pOneManager^.ud_SuperiorSyncActual := pOneManager^.ud_SuperiorSync;
            pOneManager^.ud_Counter := pOneManager^.p_Functions^.ud_VaranTime;
             
            SyncCheck := 0; // reset synchronity
          end_if;
        end_if;

        //if call time for varan master is reached
        if ( pOneManager^.ud_Counter = pOneManager^.p_Functions^.ud_VaranTime ) then
          
          //reset task time counter
          pOneManager^.ud_Counter := 0;

          //call realtime methode of VaranMaster
          pOneManager^.p_Functions^.p_This^.RtWork( 0 );            
          
          // if manager is also client and we are in superior task
          if (pOneManager^.p_Functions^.b_IsAlsoClient = 1) & (pOneManager^.p_Functions^.b_OverrideFrameCheck = FALSE) then
            if (pOneManager^.ud_SuperiorSyncActual MOD pOneManager^.ud_SuperiorSync) = 0 then
              pOneManager^.ud_SuperiorSyncActual := 0;

              SyncCheck := (SyncCheck SHL 1) OR (Act <> Old);

              if (SyncCheck = 16#FF) then
                pOneManager^.p_Functions^.b_HWClassSynchron := TRUE;
              else
                pOneManager^.p_Functions^.b_HWClassSynchron := FALSE;
              end_if;
            elsif (pOneManager^.ud_SuperiorSyncActual > pOneManager^.ud_SuperiorSync) then
              pOneManager^.ud_SuperiorSyncActual := 0;
            end_if;
          end_if;
        else
          if (pOneManager^.p_Functions^.b_IsAlsoClient & (pOneManager^.p_Functions^.b_OverrideFrameCheck = FALSE) &
             ((pOneManager^.p_Functions^.ud_SuperiorTime > pOneManager^.p_Functions^.ud_VaranTime) |
             (pOneManager^.ud_SuperiorSyncActual MOD pOneManager^.ud_SuperiorSync)) &
             pOneManager^.p_Functions^.p_This^.FrameCounterChanged(#Old, #Act)) then
            //set task time counter to HwControl task time
            pOneManager^.ud_Counter := 0;
            pOneManager^.ud_SuperiorSyncActual := 0;
            SyncCheck := 0;  // reset synchronity
          end_if;
        end_if;

        // add task time to counter
        pOneManager^.ud_Counter += ud_MyRtTaskTime;          

        // increase cycle counter
        pOneManager^.ud_SuperiorSyncActual += 1;
      end_if;
      
      pOneManager += sizeof(t_OneVaranManager);
    end_for;	
  
    //----------------------------------------------------------------------------
    //DiasMaster
    //look if we have a correct pointer
    if ( s_DiasMaster.p_Functions <> NIL ) then
    
      //if call time for dias master is reached
      if ( s_DiasMaster.ud_Counter = s_DiasMaster.p_Functions^.ud_DiasTime ) then
    
        //set task time counter to HwControl task time
        s_DiasMaster.ud_Counter := ud_MyRtTaskTime;

        CallPtr	( p_function	:= s_DiasMaster.p_Functions^.p_RtFunction
            , p_this		:= s_DiasMaster.p_Functions^.p_This
            );
    
      else
        //add task time to counter
        s_DiasMaster.ud_Counter += ud_MyRtTaskTime;
      end_if;
    end_if;
    
    // special classes, which are controlled by HwControl
    if pSpecialObjects then
      pHelp := pSpecialObjects;
      while pHelp <> NIL do
        pHelp^.pThis^.RtWork(0);
        pHelp := pHelp^.pNext;
      end_while;
    end_if;
    
    // objects, which are controlled by HwControl
    if pHwControlLogins then
      pHelp := pHwControlLogins;
      while pHelp <> NIL do
        if pHelp^.bdSettings.RtPreScan then
          pHelp^.pThis^.RtWork(CALL_OPTION_RT_PRESCAN);
        end_if;

        pHelp := pHelp^.pNext;
      end_while;
    end_if;


    // if someone wants to debug realtime or we are in startup phase (only 1 rt object possible to start while init is running)
    if RtDebug | (_FirstScan & (b_PostScanStarted = FALSE)) then
      PostScanWork();
      if (RtDebug = 0) then
        ud_LastPostScanWorkCall := OS_READMICROSEC();
      end_if;
    end_if;
  end_if;

  state:= READY;

END_FUNCTION //VIRTUAL GLOBAL HwControl::RtWork
//[#ENGLISH]
//=================================================================================================
//Function to add a VaranMaster to HwControl list
//=================================================================================================
//[server]	State				:W		:server shows error state of HwControl class
//[members]	a_VaranManager		:W		:array of structures for VaranMaster functions and settings
//[>ud_master_number]number of varan master
//[>p_function_list]pointer to function list and settings of VaranMaster
FUNCTION GLOBAL HwControl::AddVaranManager
  VAR_INPUT
    ud_manager_number	: UDINT;
    p_function_list		: ^void;
  END_VAR
  VAR_OUTPUT
    sd_retval			: DINT;
  END_VAR

  //is class ok
  if ( State = _ClassOk ) then

    //look if it is a correct VaranManager number
    if	( ud_manager_number >= 0
      & ud_manager_number <= MAX_VARAN_MANAGERS - 1
      )
    then
  
      //is this number already in use
      if ( a_VaranManager[ ud_manager_number ].p_Functions <> NIL ) then

        State											:= _NotInitialized;		//Set to error state
        a_VaranManager[ ud_manager_number ].p_Functions	:= NIL;
        sd_retval 										:= -1;

        TRACE( "HwControl: Multiple VaranManager number!" );

      end_if;

      //load pointer to varan functions
      a_VaranManager[ ud_manager_number ].p_Functions$^void := p_function_list;

      //look if varan time is bigger or equal as our task time
      if ( a_VaranManager[ ud_manager_number ].p_Functions^.ud_VaranTime < GetMyTaskTime() ) then

        State											:= _VaranTimeError;		//Set to error state
        a_VaranManager[ ud_manager_number ].p_Functions	:= NIL;
        sd_retval 										:= -1;

        TRACE( "HwControl: VaranManager time is smaller than HwControl RT-Task!" );

      //look if varan time is a multiple time of our task time
      elsif ( a_VaranManager[ ud_manager_number ].p_Functions^.ud_VaranTime mod GetMyTaskTime() <> 0 ) then

        State											:= _VaranTimeError;		//Set error state
        a_VaranManager[ ud_manager_number ].p_Functions	:= NIL;
        sd_retval 										:= -1;

        TRACE( "HwControl: VaranManager time is not a multiple  of HwControl RT-Task!" );
  
      else
    
        //set counter to time to execute task at first realtime
        a_VaranManager[ ud_manager_number ].ud_Counter := a_VaranManager[ ud_manager_number ].p_Functions^.ud_VaranTime;
        sd_retval 	:= 0;

        a_VaranManager[ ud_manager_number ].ud_SuperiorSync := a_VaranManager[ ud_manager_number ].p_Functions^.ud_SuperiorTime / ud_MyRtTaskTime;
        a_VaranManager[ ud_manager_number ].ud_SuperiorSyncActual := a_VaranManager[ ud_manager_number ].ud_SuperiorSync;
        
        // if the own tasktime is slower then superior varantime, don't wait for HW-Class Synchronity
        if ud_MyRtTaskTime > a_VaranManager[ ud_manager_number ].p_Functions^.ud_SuperiorTime then
          a_VaranManager[ ud_manager_number ].p_Functions^.b_HWClassSynchron := TRUE;
          a_VaranManager[ ud_manager_number ].p_Functions^.b_OverrideFrameCheck := TRUE;
        end_if;

        // at least 1 varanmanager is avaliable
        bVaranManagerAvailable := TRUE;

      end_if;
  
    else
      sd_retval := -1;			//manager number wrong
      TRACE( "HwControl: Wrong VaranManagerNumber!" );
    end_if;
  end_if;

END_FUNCTION //GLOBAL HwControl::AddVaranManager
//[#ENGLISH]
//=================================================================================================
//Class to call a function pointer
//=================================================================================================
//[>p_function]pointer to function that will be called
//[>p_this]thispointer of object
FUNCTION HwControl::CallPtr
  VAR_INPUT
    p_function	: pFct;
    p_this		: pVoid;
  END_VAR
  VAR
    save_this   :^HwControl;
  END_VAR

  save_this := this;            //save this ptr
  this := p_this$^HwControl;    //load thispointer of object
  p_function$ObjectFunct();     //call function of object
  this := save_this;            //restore this ptr

END_FUNCTION // HwControl::CallPtr
//=================================================================================================
//Class to call a function pointer
//=================================================================================================
//[>p_function]pointer to function should be called
//[>p_this]thispointer of object
FUNCTION AWL HwControl::CallPtr_AWL
  VAR_INPUT
    p_function	: DINT;
    p_this		: DINT;
  END_VAR
#ifdef _LSL_TARGETARCH_X86

  pushad
  l.esi		p_this				//load esi with thispointer of object
  l.eax		p_function			//load function pointer
  call		eax					//call function of object
  popad
#endif
END_FUNCTION // HwControl::CallPtr
//[#ENGLISH]
//=================================================================================================
//Function to get Tasktime of Hwcontrol class
//=================================================================================================
//[members]	ud_MyTaskTime		:R/W	:variable for out tasktime of realtime task
//[locals]	s_objinfo			:W/R	:variable for objectinfo
//[<sd_task_time]rt task time in us
FUNCTION GLOBAL HwControl::GetMyTaskTime
  VAR_OUTPUT
    ud_task_time 	: UDINT;
  END_VAR
  VAR
    s_objinfo 		: LSLOBJ_INFO;
    sd_retval : DINT;
  END_VAR

  //have we a task time
  if ( ud_MyRtTaskTime = 0 ) then
    
    //get objectinfo of VaranMaster
    To_TaskObjectControl.GetObjectInfo( thispointer := this, tasktype := OBJ_RT, objinfo := #s_objinfo );
    
    //if we have ms
    if ( s_objinfo.period > 0 ) then
    
      //look if we have µs or ms (µs msb is set)
      if ( ( s_objinfo.period and 16#8000_0000 ) = 0 ) then
        
        //we need our task time in ns
        ud_MyRtTaskTime := s_objinfo.period * 1000000;
      else

        //we have µs seconds but we neeed ns
        ud_MyRtTaskTime := ( s_objinfo.period and 16#7FFF_FFFF ) * 1000;
      end_if;
    end_if;

    // if cyclic task is not active => activate it with 1ms
    sd_retval := To_TaskObjectControl.GetObjectInfo(thispointer:=this, tasktype:=OBJ_CT, objinfo:=#s_objinfo);

    // if there is no cyclic task for this object
    if ( sd_retval = -5 ) then
      // add the task to the list
      sd_retval := To_TaskObjectControl.ChangeObjectState(thispointer:=this, actioncmd:=ACTION_ADD, tasktype:=OBJ_CT, debugobj:=0, newtime:=1);
      
      // couldn't add cyclic task => class will not work
      if sd_retval <> 0 then
        State := _CallBackError;
        return;
      end_if;
      // activate the task
      sd_retval := To_TaskObjectControl.ChangeObjectState(thispointer:=this, actioncmd:=ACTION_CONTNUE, tasktype:=OBJ_CT, debugobj:=0, newtime:=1);
      
      // couldn't activate cyclic task => class will not work
      if sd_retval <> 0 then
        State := _CallBackError;
        return;
      end_if;
      
      //we need our task time in ns
      ud_MyCyTaskTime := 1000000;
      
    elsif ( s_objinfo.period > 0 ) then
    
      //look if we have µs or ms (µs msb is set)
      if ( ( s_objinfo.period and 16#8000_0000 ) = 0 ) then
        
        //we need our task time in ns
        ud_MyCyTaskTime := s_objinfo.period * 1000000;
      else

        //we have µs seconds but we neeed ns
        ud_MyCyTaskTime := ( s_objinfo.period and 16#7FFF_FFFF ) * 1000;
      end_if;
    end_if;
  end_if;

  ud_task_time := ud_MyRtTaskTime;		//give back task time

END_FUNCTION // HwControl::GetMyTaskTime
//[#ENGLISH]
//=================================================================================================
//Write Function of DiasMaster
//=================================================================================================
//[server]	State				:W		:server shows error state of HwControl class
//			DiasMaster			:W		:server which is connected to DiasMaster
//[members]	s_DiasMaster		:W		:pointer to DiasMaster functions and settings
 //VIRTUAL GLOBAL HwControl::DiasMaster::Write
//[#ENGLISH]
//=================================================================================================
//Function sets Hardware off
//=================================================================================================
//[server]	State			:W		:server shows error state of HwControl class
//[>e_error]reason why hardware is set off
FUNCTION GLOBAL HwControl::SetHardwareOff
  VAR_INPUT
    e_error		: t_e_VaranErrors;
  END_VAR
  VAR
    MyPara    : CmdStruct;
    MyResult  : results;
  END_VAR

  State := e_error;
  
  // if a diasmaster is available => tell him
  if s_DiasMaster.p_Functions then
    MyPara.uiCmd := CMD_HWC_ERROR_TO_DIASM;
    s_DiasMaster.p_Functions^.p_This$pVirtualBase^.NewInst(#MyPara,#MyResult);
  end_if;

END_FUNCTION //GLOBAL HwControl::SetHardwareOff
//[#ENGLISH]
//=================================================================================================
//Function returns Debug State
//=================================================================================================
FUNCTION GLOBAL HwControl::GetRtDebugState
  VAR_OUTPUT
    sd_RtDebug		: DINT;
  END_VAR

  sd_RtDebug := RtDebug.read();

END_FUNCTION //GLOBAL HwControl::GetRtDebugState


FUNCTION VIRTUAL GLOBAL HwControl::UpdateRtPostScan

  // first time postscan is called by os
  if b_PostScanStarted = FALSE then
    b_PostScanStarted := TRUE;
    if p_WatchdogAPI then
      //turn of watchdogtask of os because we trigger it in application
      OS_WD_SETPROPERTY(p_WatchdogAPI, Property:=WD_PROP_APPL_WD, value:=1); // 1 to disable autotrigger
    end_if;   
    // if we've already done postscan work from prescan, don't do anything here
    ud_FirstPostScanCall := OS_READMICROSEC();
    // check if already called in same cycle => my task time in ns recalculated to 80 percent of the task time in µs
    if (ud_FirstPostScanCall - ud_LastPostScanWorkCall) < (ud_MyRtTaskTime / 1250) then
      return;
    end_if;
  end_if;

  PostScanWork();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL HwControl::DiasMaster::Write
  VAR_INPUT
    input (EAX) 	: DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX) 	: DINT;
  END_VAR

  //is it a required error from dias master?
  if input = 0 then
    State := _RequiredError;
    return;
  end_if;

  //is class ok
  if ( State = _ClassOk ) then

    s_DiasMaster.p_Functions$DINT := input;		//load pointer to DiasMaster functions

    //convert time into ns (to be compatible)
    s_DiasMaster.p_Functions^.ud_DiasTime := s_DiasMaster.p_Functions^.ud_DiasTime * 1000;

    //look if DiasMaster time is bigger or equal as our task time
    if ( ( s_DiasMaster.p_Functions^.ud_DiasTime ) < GetMyTaskTime() ) then

      State						:= _DiasTimeError;			//Set to error state
      s_DiasMaster.p_Functions	:= NIL;
      result 						:= -1;

      TRACE( "HwControl: DiasMaster time is smaller than HwControl RT-Task!" );

      return;

    //look if DiasMaster time is a multiple time of our task time
    elsif ( ( s_DiasMaster.p_Functions^.ud_DiasTime ) mod GetMyTaskTime() <> 0 ) then

      State						:= _DiasTimeError;			//Set to error state
      s_DiasMaster.p_Functions	:= NIL;
      result						:= -1;

      TRACE( "HwControl: DiasMaster time is not a multiple of HwControl RT-Task!" );
  
      return;

    else
    
      //set counter to time to execute task at first realtime
      s_DiasMaster.ud_Counter := s_DiasMaster.p_Functions^.ud_DiasTime;

      result 					:= 0;

      DiasMaster := input := 1;				//Mark server as connected right

    end_if;

    //set RtDebug-Flag for DiasMaster
    s_DiasMaster.p_Functions^.sd_RtDebug := RtDebug.Read();
  else
    result := -1;
  end_if;

END_FUNCTION


FUNCTION GLOBAL HwControl::AddSpecialHW
  VAR_INPUT
    pThis 	: pVirtualBase;
    pRtPostScan 	: ^UDINT;
  END_VAR
  VAR_OUTPUT
    retcode 	: DINT;
  END_VAR
  VAR
    pHelp : ^t_HwObjectListElement;
  END_VAR

  if pSpecialObjects = NIL then
    pSpecialObjects$pVoid := To_StdLib.Malloc(size:=sizeof(t_HwObjectListElement));
    pHelp := pSpecialObjects;
  else
    pHelp := pSpecialObjects;
    while pHelp^.pNext <> NIL do
      pHelp := pHelp^.pNext;
    end_while;
    pHelp^.pNext$pVoid := To_StdLib.Malloc(size:=sizeof(t_HwObjectListElement));
    pHelp := pHelp^.pNext;
  end_if;
  
  if pHelp <> NIL then
    pHelp^.pThis := pThis;
    pHelp^.pRtPostScan := pRtPostScan;
    pHelp^.pNext   := NIL;
    retcode := 0;
  else
    retcode := -1;
  end_if;

END_FUNCTION


FUNCTION HwControl::PostScanWork
  VAR
    i : DINT;
    p_OneManager : ^t_OneVaranManager;
    pHelp : ^t_HwObjectListElement;
  END_VAR

  if State = _ClassOk then
    // objects, which are controlled by HwControl (call before the other hardware classes because the safety manager may start moving the data to another system)
    if pHwControlLogins then
      pHelp := pHwControlLogins;
      while pHelp <> NIL do
        if pHelp^.bdSettings.RtPostScan then
          pHelp^.pThis^.RtWork(CALL_OPTION_RT_POSTSCAN);
        end_if;

        pHelp := pHelp^.pNext;
      end_while;
    end_if;


    p_OneManager := #a_VaranManager[0];
    FOR i := 0 TO (MAX_VARAN_MANAGERS - 1) DO
      IF p_OneManager^.p_Functions <> NIL & p_OneManager^.ud_Counter = ud_MyRtTaskTime THEN
        p_OneManager^.p_Functions^.p_This^.UpdateRtPostscan();
        p_OneManager += SIZEOF(t_OneVaranManager);    
      END_IF;
    END_FOR;

  //-------------------------------------Profiler Start----------------------------------------------
  //#WP001 Start
  #ifdef	DiasMasterC_Profiler
#ifdef _LSL_TARGETARCH_X86
    CLI();											//damit keine Interrupts die Messung stören
#endif
    
    HWC_Time_RTPostscan.start := OS_ReadMicroSec();
    if ( ( HWC_Time_RTPostscan.start - HWC_Time_RTPostscan.init ) > DM_ProfilerDelay ) then
      HWC_Time_RTPostscan.initfl := 0;
    else
      HWC_Time_RTPostscan.initfl := 1;
    end_if;
  #endif
  //#WP001 End
  //-------------------------------------Profiler End------------------------------------------------

    IF s_DiasMaster.p_Functions <> NIL THEN
      IF s_DiasMaster.p_Functions^.p_RtPostScanFunction <> NIL THEN
        CallPtr	( p_function := s_DiasMaster.p_Functions^.p_RtPostScanFunction
                , p_this     := s_DiasMaster.p_Functions^.p_This
                );
      END_IF;
    END_IF;
    
    // special classes, which are controlled by HwControl
    if pSpecialObjects then
      pHelp := pSpecialObjects;
      while pHelp <> NIL do
        pHelp^.pRtPostScan$RtWork((pHelp^.pThis)$UDINT);
        pHelp := pHelp^.pNext;
      end_while;
    end_if;

    // if interface is available trigger watchdog 
    if p_WatchdogAPI then
      OS_WD_TRIGGER(p_WatchdogAPI);
    end_if;

  //-------------------------------------Profiler Stop----------------------------------------------
  //#WP001 Start
  #ifdef DiasMasterC_Profiler
    if ( HWC_Time_RTPostscan.initfl = 0 ) then

      HWC_Time_RTPostscan.stop := OS_ReadMicroSec();
      HWC_Time_RTPostscan.diff := HWC_Time_RTPostscan.stop - HWC_Time_RTPostscan.start - DM_CPUconstant;
      HWC_Time_RTPostscan.sum += HWC_Time_RTPostscan.diff;
      HWC_Time_RTPostscan.run += 1;

      if ( HWC_Time_RTPostscan.diff < HWC_Time_RTPostscan._min ) then
        HWC_Time_RTPostscan._min := HWC_Time_RTPostscan.diff;
      end_if;

      if ( HWC_Time_RTPostscan.diff > HWC_Time_RTPostscan._max ) then
        HWC_Time_RTPostscan._max := HWC_Time_RTPostscan.diff;
      end_if;

      HWC_Time_RTPostscan.avg := HWC_Time_RTPostscan.sum * 100 / HWC_Time_RTPostscan.run;

    end_if;
#ifdef _LSL_TARGETARCH_X86
    STI();
#endif
  #endif
  //#WP001 End
  //-------------------------------------Profiler End------------------------------------------------

  end_if;
  
END_FUNCTION

#pragma warning(disable: 73)
FUNCTION VIRTUAL GLOBAL HwControl::AddSafetyManager
  VAR_INPUT
    pThis 	: pVirtualBase;
  END_VAR
  VAR_OUTPUT
    pFirstVM 	: pVirtualBase;
  END_VAR
#pragma warning(default: 73)

// NO LONGER USED SINCE HWCONTROL HAS IT'S OWN CYCLIC TASK

(*
  VAR
    i : DINT;
    p_OneManager : ^t_OneVaranManager;
  END_VAR

  // we need to inform either the VaranManager (if available) or the DiasMaster (if available) about it, to call the CyWork of it (because HwControl got no cyclic task)
*)
  pFirstVM := NIL;
(*
  // check varan managers
  p_OneManager := #a_VaranManager[0];
  FOR i := 0 TO (MAX_VARAN_MANAGERS - 1) DO
    IF p_OneManager^.p_Functions <> NIL THEN
      if p_OneManager^.p_Functions^.SafetyManagerThisPointer then
        p_OneManager^.p_Functions^.SafetyManagerThisPointer^ := pThis;
        pSafetyManagerThis := pThis;
        pFirstVM := p_OneManager^.p_Functions^.p_This$pVirtualBase;
        return;
      end_if;
    END_IF;
    p_OneManager += SIZEOF(t_OneVaranManager);    
  END_FOR;

  // check diasmaster
  if ( s_DiasMaster.p_Functions <> NIL ) then
    if s_DiasMaster.p_Functions^.SafetyManagerThisPointer then
      s_DiasMaster.p_Functions^.SafetyManagerThisPointer^ := pThis;
      pSafetyManagerThis := pThis;
      return;
    end_if;
  end_if;
  
  // no target found
  TRACE("SafetyManager needs either an object of VaranManager or DiasMasterC");
*)
END_FUNCTION


FUNCTION VIRTUAL GLOBAL HwControl::SafetyState::Read
  VAR_OUTPUT
    output (EAX) 	: DINT;
  END_VAR

  SafetyState := SafetyManager.ClassState.Read();
  output := SafetyState;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL HwControl::DisableSafetyManager

// NO LONGER USED SINCE HWCONTROL HAS IT'S OWN CYCLIC TASK

(*
  VAR
    i : DINT;
    p_OneManager : ^t_OneVaranManager;
  END_VAR
  
  // reset pointer to disable rt calls
  pSafetyManagerThis := NIL;

  // we need to inform either the VaranManager (if available) or the DiasMaster (if available) about it, to not call the CyWork of it

  // check varan managers
  p_OneManager := #a_VaranManager[0];
  FOR i := 0 TO (MAX_VARAN_MANAGERS - 1) DO
    IF p_OneManager^.p_Functions <> NIL THEN
      if p_OneManager^.p_Functions^.SafetyManagerThisPointer then
        p_OneManager^.p_Functions^.SafetyManagerThisPointer^ := NIL;
        return;
      end_if;
    END_IF;
    p_OneManager += SIZEOF(t_OneVaranManager);    
  END_FOR;

  // check diasmaster
  if ( s_DiasMaster.p_Functions <> NIL ) then
    if s_DiasMaster.p_Functions^.SafetyManagerThisPointer then
      s_DiasMaster.p_Functions^.SafetyManagerThisPointer^ := NIL;
      return;
    end_if;
  end_if;
*)
END_FUNCTION


FUNCTION VIRTUAL GLOBAL HwControl::Control::NewInst
  VAR_INPUT
    pPara 	: ^CmdStruct;
    pResult 	: ^Results;
  END_VAR
  VAR_OUTPUT
    ret_code 	: IprStates;
  END_VAR
  VAR
    StartTime : UDINT;
    pOneManager : ^t_OneVaranManager;
    i : DINT;
    TempRetCode : IprStates;
    MyPara : CmdStruct;
    MyResult : results;
    pHelp : ^t_HwObjectListElement;
    TempSettings : t_HwObjListSettings;

    us_ModuleType : HSINT;
    pStr_HWTRequested  : ^CHAR;
    pStr_HWTreeEntry   : ^CHAR;
    
  END_VAR
  
  us_ModuleType     := 0;
  pStr_HWTRequested := NIL;
  pStr_HWTreeEntry  := NIL;

  ret_code := READY;
  
  CASE pPara^.uiCmd OF
//**********************************************************************************************************************************************************
    CMD_POST_INIT_CALL:

//**********************************************************************************************************************************************************
//** INITIALIZE EVERYTHING VIA ASYNCHRON ACCESSES                                                                                                         **
//**********************************************************************************************************************************************************
    
      ret_code := BUSY;
      
      StartTime := ops.tAbsolute;
      while (ret_code = BUSY) do
        // check the varanmanagers if they are not ready
        ret_code := READY;

        // only if there is a varan manager
        if a_VaranManager[0].p_Functions & a_VaranManager[0].p_Functions^.p_This then
          //call the last init of all varan managers
          pOneManager := #a_VaranManager[0];  // RamAnd: using pointers instead of array accesses reduces compiled awl-code by 120 lines!!!
          for i := 0 to ( MAX_VARAN_MANAGERS - 1 ) do

            //look if we have a correct pointer
            if ( pOneManager^.p_Functions^.p_This ) then
              TempRetCode := pOneManager^.p_Functions^.p_This^.NewInst(pPara, pResult);
              
              // if any manager is still busy, we have to keep calling them
              if TempRetCode = BUSY then
                ret_code := TempRetCode;
              end_if;
            end_if;

            pOneManager += sizeof(t_OneVaranManager);
          end_for;                    
        end_if;

        // objects, which are controlled by HwControl
        if pHwControlLogins then
          pHelp := pHwControlLogins;
          while pHelp <> NIL do
            if pHelp^.bdSettings.PostInit then
              TempRetCode := pHelp^.pThis^.NewInst(pPara, pResult);
              // if any manager is still busy, we have to keep calling them
              if TempRetCode = BUSY then
                ret_code := TempRetCode;
              end_if;
            end_if;

            pHelp := pHelp^.pNext;
          end_while;
        end_if;

        // check timeout
        if ((ops.tAbsolute - StartTime) > POST_INIT_TIMEOUT) then
          TRACE("(HwControl::Control::NewInst) Timeout in PostInit (initialize)");
          // only if there is a varan manager
          if a_VaranManager[0].p_Functions & a_VaranManager[0].p_Functions^.p_This then

            // Force all VM to end the PostInit Phase, Otherwise UpdateCy of HWK will not be called -----------------------------------------
            MyPara.uiCmd := CMD_FORCE_POST_INIT_END;

            //call the last init of all varan managers
            pOneManager := #a_VaranManager[0];
            for i := 0 to ( MAX_VARAN_MANAGERS - 1 ) do

              //look if we have a correct pointer
              if ( pOneManager^.p_Functions^.p_This ) then
                TempRetCode := pOneManager^.p_Functions^.p_This^.NewInst(#MyPara, #MyResult);
              end_if;

              pOneManager += sizeof(t_OneVaranManager);
            end_for;	// ---------------------------------------------------------------------------------------------------------------------------------------------
          end_if;
          exit;
        end_if;
      end_while;


//**********************************************************************************************************************************************************
//** SORT THE VARAN DOs NEEDED FOR SAFETY                                                                                                                 **
//**********************************************************************************************************************************************************

      MyPara.uiCmd := CMD_POST_INIT_DO_SORT;
      
      // only if there is a varan manager
      if a_VaranManager[0].p_Functions & a_VaranManager[0].p_Functions^.p_This then
        //send the finish command to all varan managers
        pOneManager := #a_VaranManager[0];
        for i := 0 to ( MAX_VARAN_MANAGERS - 1 ) do

          //look if we have a correct pointer
          if ( pOneManager^.p_Functions^.p_This ) then
            TempRetCode := pOneManager^.p_Functions^.p_This^.NewInst(pPara:=#MyPara, pResult:=#MyResult);
            
            // if any manager is still busy, we have to keep calling them
            if TempRetCode = BUSY then
              ret_code := TempRetCode;
            end_if;
          end_if;

          pOneManager += sizeof(t_OneVaranManager);
        end_for;                    
      end_if;

//**********************************************************************************************************************************************************
//** START THE REALTIME OF HWCONTROL                                                                                                                      **
//**********************************************************************************************************************************************************

      //bring HwControl to the first realtime task position and start realtime task
      OS_MoveObject( this, 2, 1 );
      OS_SetNbrOfLdrPhaseObjects( 1 );

//**********************************************************************************************************************************************************
//** WAIT FOR RT TO TAKE OVER THE WATCHDOG TRIGGERING                                                                                                     **
//**********************************************************************************************************************************************************

      MyPara.uiCmd := CMD_POST_INIT_RT_SYNC;
      ret_code := BUSY;
      
      StartTime := ops.tAbsolute;
      while (ret_code = BUSY) do
        // check the varanmanagers if they are not ready
        ret_code := READY;

        // only if there is a varan manager
        if a_VaranManager[0].p_Functions & a_VaranManager[0].p_Functions^.p_This then
          //send the finish command to all varan managers
          pOneManager := #a_VaranManager[0];
          for i := 0 to ( MAX_VARAN_MANAGERS - 1 ) do

            //look if we have a correct pointer
            if ( pOneManager^.p_Functions^.p_This ) then
              TempRetCode := pOneManager^.p_Functions^.p_This^.NewInst(pPara:=#MyPara, pResult:=#MyResult);
              
              // if any manager is still busy, we have to keep calling them
              if TempRetCode = BUSY then
                ret_code := TempRetCode;
              end_if;
            end_if;

            pOneManager += sizeof(t_OneVaranManager);
          end_for;                    
        end_if;

        // objects, which are controlled by HwControl
        if pHwControlLogins then
          pHelp := pHwControlLogins;
          while pHelp <> NIL do
            if pHelp^.bdSettings.PostInit then
              TempRetCode := pHelp^.pThis^.NewInst(pPara:=#MyPara, pResult:=#MyResult);
              // if any manager is still busy, we have to keep calling them
              if TempRetCode = BUSY then
                ret_code := TempRetCode;
              end_if;
            end_if;

            pHelp := pHelp^.pNext;
          end_while;
        end_if;

        // check timeout
        if ((ops.tAbsolute - StartTime) > POST_INIT_TIMEOUT) then
          TRACE("(HwControl::Control::NewInst) Timeout in PostInit (rt sync)");
          // only if there is a varan manager
          if a_VaranManager[0].p_Functions & a_VaranManager[0].p_Functions^.p_This then

            // Force all VM to end the PostInit Phase, Otherwise UpdateCy of HWK will not be called -----------------------------------------
            MyPara.uiCmd := CMD_FORCE_POST_INIT_END;

            //call the last init of all varan managers
            pOneManager := #a_VaranManager[0];  // RamAnd: using pointers instead of array accesses reduces compiled awl-code by 120 lines!!!
            for i := 0 to ( MAX_VARAN_MANAGERS - 1 ) do

              //look if we have a correct pointer
              if ( pOneManager^.p_Functions^.p_This ) then
                TempRetCode := pOneManager^.p_Functions^.p_This^.NewInst(#MyPara, #MyResult);
              end_if;

              pOneManager += sizeof(t_OneVaranManager);
            end_for;	// ---------------------------------------------------------------------------------------------------------------------------------------------
          end_if;
          exit;
        end_if;
      end_while;


//**********************************************************************************************************************************************************
//** LOAD THE SAFETY PROJECT CONFIGURATIONS AT THE SAFETY CPUS                                                                                            **
//**********************************************************************************************************************************************************

      // tell the available safety cpu modules to get their configurations now!
      MyPara.uiCmd := CMD_SM_POST_INIT_FINISHED;
      SafetyManager.ClassState.NewInst(pPara:=#MyPara, pResult:=#MyResult);


//**********************************************************************************************************************************************************
//** FINISH DIAS/CDIAS                                                                                                                                    **
//**********************************************************************************************************************************************************

      //look if DiasMaster is also used ( must be after starting realtime task )
      if ( s_DiasMaster.p_Functions <> NIL ) then
        
        //make final initialization in DiasMaster
        CallPtr	( p_function	:= s_DiasMaster.p_Functions^.p_LastInit
                , p_this		  := s_DiasMaster.p_Functions^.p_This
                );
      end_if;


//**********************************************************************************************************************************************************
//** FINISH VARAN/SDIAS                                                                                                                                   **
//**********************************************************************************************************************************************************

      MyPara.uiCmd := CMD_POST_INIT_RT_READY;
      ret_code := BUSY;
      
      StartTime := ops.tAbsolute;
      while (ret_code = BUSY) do
        // check the varanmanagers if they are not ready
        ret_code := READY;

        // only if there is a varan manager
        if a_VaranManager[0].p_Functions & a_VaranManager[0].p_Functions^.p_This then
          //send the finish command to all varan managers
          pOneManager := #a_VaranManager[0];
          for i := 0 to ( MAX_VARAN_MANAGERS - 1 ) do

            //look if we have a correct pointer
            if ( pOneManager^.p_Functions^.p_This ) then
              TempRetCode := pOneManager^.p_Functions^.p_This^.NewInst(pPara:=#MyPara, pResult:=#MyResult);
              
              // if any manager is still busy, we have to keep calling them
              if TempRetCode = BUSY then
                ret_code := TempRetCode;
              end_if;
            end_if;

            pOneManager += sizeof(t_OneVaranManager);
          end_for;                    
        end_if;

        // objects, which are controlled by HwControl
        if pHwControlLogins then
          pHelp := pHwControlLogins;
          while pHelp <> NIL do
            if pHelp^.bdSettings.PostInit then
              TempRetCode := pHelp^.pThis^.NewInst(pPara:=#MyPara, pResult:=#MyResult);
              // if any manager is still busy, we have to keep calling them
              if TempRetCode = BUSY then
                ret_code := TempRetCode;
              end_if;
            end_if;

            pHelp := pHelp^.pNext;
          end_while;
        end_if;

        // check timeout
        if ((ops.tAbsolute - StartTime) > POST_INIT_TIMEOUT) then
          TRACE("(HwControl::Control::NewInst) Timeout in PostInit (finishing)");
          // only if there is a varan manager
          if a_VaranManager[0].p_Functions & a_VaranManager[0].p_Functions^.p_This then

            // Force all VM to end the PostInit Phase, Otherwise UpdateCy of HWK will not be called -----------------------------------------
            MyPara.uiCmd := CMD_FORCE_POST_INIT_END;

            //call the last init of all varan managers
            pOneManager := #a_VaranManager[0];  // RamAnd: using pointers instead of array accesses reduces compiled awl-code by 120 lines!!!
            for i := 0 to ( MAX_VARAN_MANAGERS - 1 ) do

              //look if we have a correct pointer
              if ( pOneManager^.p_Functions^.p_This ) then
                TempRetCode := pOneManager^.p_Functions^.p_This^.NewInst(#MyPara, #MyResult);
              end_if;

              pOneManager += sizeof(t_OneVaranManager);
            end_for;	// ---------------------------------------------------------------------------------------------------------------------------------------------
          end_if;
          exit;
        end_if;
      end_while;

//**********************************************************************************************************************************************************
    CMD_HWCONTROL_LOGIN:
      TempSettings := pPara^.aPara[1]$t_HwObjListSettings;      
      us_ModuleType := pPara^.aPara[2]$USINT;
      
      if (us_ModuleType AND HWT_ESCAPE_SEQU) = 0 then      
        us_ModuleType := 0; // MSB must be set for a valid Escape Sequence
      end_if;
      
      AddHwObject(pThis:=pPara^.aPara[0]$pVirtualBase, Settings:=TempSettings, EscapeSequence:=us_ModuleType);

      // ensure that the values for the tasks are available
      GetMyTaskTime();

      pResult^.uiLng := 8;
      pResult^.aData[0]$UDINT := ud_MyRtTaskTime;      
      pResult^.aData[4]$UDINT := ud_MyCyTaskTime;
      
      // post init callback is only possible if the method is supported by loader
      if TempSettings.PostInit & (InstallPostInitCB() <> 0) then
        ret_code := ERROR;
      end_if;

//**********************************************************************************************************************************************************
  CMD_GET_HARDWARE_TREE_ENTRY:
   
    //Reset all Return Values
    pResult^.aData$t_HWCGetHardwareTreeEntryOut.pStr_NextHardewareTreeEntry := nil;
    pResult^.aData$t_HWCGetHardwareTreeEntryOut.retcode := _HWC_RETVAL_ERROR; 
    ret_code := ERROR;
    
    pStr_HWTreeEntry  :=  pPara^.aPara[0]$t_HWCGetHardwareTreeEntryIn.pStr_LastHardewareTreeEntry;

    // if nil, search the first module ==================================================================================================================
    if pPara^.aPara$t_HWCGetHardwareTreeEntryIn.pStr_LastHardewareTreeEntry = nil then
         
      // Call all managers and search the module      
      us_ModuleType := HWT_ESCAPE_VARAN; // 1. entry rquested, start with Varan HWKs
    
    //Search the next module =============================================================================================================================
    //Only when there is a valid length we can access the data
    elsif (pStr_HWTreeEntry$^UINT^ <> 0) then // Length is 2 byte
      
      // 3 byte is domain
      // 4 byte is bus type/escape sequence.
      us_ModuleType := (pStr_HWTreeEntry+3)^$USINT;  

      //Current Index = 4 because first 2 bytes are length, one byte domain number, next byte is escape sequence, 5th byte is port number
      pPara^.aPara[0]$t_HWCGetHardwareTreeEntryIn.us_current_index  := 4;  //points to escape sequence
      
      //Current length is length - 2 (point above domain number and escape sequence)
      pPara^.aPara[0]$t_HWCGetHardwareTreeEntryIn.us_current_length$UINT := pStr_HWTreeEntry^$UINT - 2;
   
    end_if;    
      
    //Go through all managers
    //Varan -------------------------------------------------------------------------------------------------------------------
    if us_ModuleType = HWT_ESCAPE_VARAN then
      // Loop over all Varanmanger
      pOneManager := #a_VaranManager[0];  // RamAnd: using pointers instead of array accesses reduces compiled awl-code by 120 lines!!!
      for i := 0 to ( MAX_VARAN_MANAGERS - 1 ) do

        //look if we have a correct pointer
        if (pOneManager^.p_Functions) & ( pOneManager^.p_Functions^.p_This ) then
          ret_code := pOneManager^.p_Functions^.p_This^.NewInst(pPara, pResult);
          
          if (ret_code = READY) then
            
            if pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.retcode = _HWC_RETVAL_OK_HWTSTR_RETURNED then
              return; // Next HWT string was returned pass it back
            end_if;
            
            if pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.retcode = _HWC_RETVAL_OK_MODULE_FOUND |
               pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.retcode = _HWC_RETVAL_OK_END_OF_LIST then
              // Module was found and was the last module in the Manager 
              // Set the requested HWT string to nil so that the next call is an autohit
              pPara^.aPara$t_HWCGetHardwareTreeEntryIn.pStr_LastHardewareTreeEntry := nil;
              
              ret_code := ERROR;  // Reset ret_code before next call              
              
            end_if;

          end_if;

        end_if;
        pOneManager += sizeof(t_OneVaranManager);
      
      end_for;   
      
      // Try next Manager
      us_ModuleType := HWT_ESCAPE_CDIAS;
    end_if;
    
    //CDIAS DIAS -------------------------------------------------------------------------------------------------------------------
    if us_ModuleType = HWT_ESCAPE_CDIAS |
       us_ModuleType = HWT_ESCAPE_DIAS then
      
      if s_DiasMaster.p_Functions then
      
        ret_code := s_DiasMaster.p_Functions^.p_This$pVirtualBase^.NewInst(pPara,pResult);
      
        if pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.retcode = _HWC_RETVAL_OK_HWTSTR_RETURNED then
          return; // Next HWT string was returned pass it back
        end_if;
        
        if pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.retcode = _HWC_RETVAL_OK_MODULE_FOUND |
           pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.retcode = _HWC_RETVAL_OK_END_OF_LIST then
          // Module was found and was the last module in the Manager 
          // Set the requested HWT string to nil so that the next call is an autohit
          pPara^.aPara$t_HWCGetHardwareTreeEntryIn.pStr_LastHardewareTreeEntry := nil;
          
          ret_code := ERROR;  // Reset ret_code before next call              
        end_if;
      
      end_if;

      // Try next Manager
      us_ModuleType := HWT_ESCAPE_SEQU;
    
    end_if;
    
     // Other (Local SDIAS)  -------------------------------------------------------------------------------------------------------------------
    if us_ModuleType AND HWT_ESCAPE_SEQU then
      if pHwControlLogins then
     
        pHelp := pHwControlLogins;
        
        while pHelp <> NIL  do 
          
          if pHelp^.usEscSequence AND HWT_ESCAPE_SEQU then
          
            ret_code := pHelp^.pThis^.NewInst(pPara, pResult);              
            
            if pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.retcode = _HWC_RETVAL_OK_HWTSTR_RETURNED then
              return; // Next HWT string was returned pass it back
            end_if;
            
            if pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.retcode = _HWC_RETVAL_OK_MODULE_FOUND |
                pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.retcode = _HWC_RETVAL_OK_END_OF_LIST then
              // Module was found and was the last module in the Manager 
              // Set the requested HWT string to nil so that the next call is an autohit
              pPara^.aPara$t_HWCGetHardwareTreeEntryIn.pStr_LastHardewareTreeEntry := nil;
              
              ret_code := ERROR;  // Reset ret_code before next call              
            end_if;
          
          end_if;
          
          pHelp := pHelp^.pNext;
          
        end_while;
        
      end_if; 
      
    end_if;
          
    // Check if no further module exits
    if pPara^.aPara$t_HWCGetHardwareTreeEntryIn.pStr_LastHardewareTreeEntry = nil then
      ret_code := READY;
      pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.retcode := _HWC_RETVAL_OK_END_OF_LIST;
      pResult^.aData[0]$t_HWCGetHardwareTreeEntryOut.pStr_NextHardewareTreeEntry := NIL;
      
    end_if;

//**********************************************************************************************************************************************************
  CMD_GET_HARDWARE_DIAGNOSIS:
  
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.retcode := _HWC_RETVAL_ERROR;
    ret_code := ERROR;
    
    // Reset all return values    
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.ClassState      := 16#FFFFFFFF$t_e_VaranErrors;  //invalid value
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.pStr_DeviceName := NIL;
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.ud_DeviceID     := HWC_INVALID_DEVICE_ID;
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.pStr_VendorName := NIL;
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.ud_VendorID     := 0;
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.pStr_SerialNo   := NIL;
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.pStr_OrderingNo := NIL;
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.ud_LicenseNo    := 0;
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.hd_HWVersion    := 0;
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.ud_Variante     := 0;
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.hd_FPGAVersion  := 0;
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.pStr_FWVersion  := NIL;
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.hd_SafetyNumber := 0;
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.ud_Place        := 16#FFFFFFFF; // Place 0 is valid
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.ud_AxisNo       := 16#FFFFFFFF;
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.ud_reserved_size:= 0;
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.pud_reserved    := NIL;
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.ud_user_size    := 0;
    pResult^.aData[0]$t_HWCGetHardwareDiagnosisOut.pud_user        := NIL;
   
    pStr_HWTRequested  :=  pPara^.aPara[0]$t_HWCGetHardwareDiagnosisIn.pStr_HardewareTreeEntry;

    //Only when there is a valid length we can access the data
    if (pStr_HWTRequested$^UINT^ <> 0) then // Length is 2 byte
      
      // 3 byte is domain
      
      // 4 byte is bus type/escape sequence.
      us_ModuleType := (pStr_HWTRequested+3)^$USINT;  

      //Current Index = 5 because first 2 bytes are length, one byte domain number, next byte is escape sequence, 5th byte is port number
      pPara^.aPara[0]$t_HWCGetHardwareDiagnosisIn.us_current_index  := 4;  //points to escape sequence
      //Current length is length - 2 (point above domain number and escape sequence)
      pPara^.aPara[0]$t_HWCGetHardwareDiagnosisIn.us_current_length$UINT := pStr_HWTRequested^$UINT - 2;
      
      case us_ModuleType of
      
        //-------------------------------------------------------------------------------------------
        HWT_ESCAPE_VARAN:
        
          // Loop over all Varanmanger
          pOneManager := #a_VaranManager[0];  // RamAnd: using pointers instead of array accesses reduces compiled awl-code by 120 lines!!!
          for i := 0 to ( MAX_VARAN_MANAGERS - 1 ) do

            //look if we have a correct pointer
            if (pOneManager^.p_Functions) & ( pOneManager^.p_Functions^.p_This ) then
              ret_code := pOneManager^.p_Functions^.p_This^.NewInst(pPara, pResult);
              
              // Module was found if retcode is ready or busy
              if (ret_code = READY) | (ret_code = BUSY) then
                exit;
              end_if;

            end_if;

            pOneManager += sizeof(t_OneVaranManager);
        
          end_for;          

        //-------------------------------------------------------------------------------------------
        HWT_ESCAPE_CDIAS:
          
          if s_DiasMaster.p_Functions then
            ret_code := s_DiasMaster.p_Functions^.p_This$pVirtualBase^.NewInst(pPara,pResult);
          end_if;
          
        //-------------------------------------------------------------------------------------------
        HWT_ESCAPE_DIAS:
      
          if s_DiasMaster.p_Functions then
            ret_code := s_DiasMaster.p_Functions^.p_This$pVirtualBase^.NewInst(pPara,pResult);
          end_if;
          
        //-------------------------------------------------------------------------------------------        
//        HWT_ESCAPE_SDIAS:
        
        // Other (SDIAS)
        else
          if pHwControlLogins then
            
            pHelp := pHwControlLogins;
            
            while pHelp <> NIL &
              ((ret_code <> READY) & (ret_code <> BUSY)) do // Module was found if retcode is ready or busy
            
              if pHelp^.usEscSequence = us_ModuleType then
                ret_code := pHelp^.pThis^.NewInst(pPara, pResult);                
              end_if;
              
              pHelp := pHelp^.pNext;
              
            end_while;
            
          end_if;
      
      end_case;
    end_if;
    
//**********************************************************************************************************************************************************
  CMD_SET_VARANMANAGER_ERROR:
  
      if a_VaranManager[0].p_Functions <> NIL then
        a_VaranManager[0].p_Functions^.p_This^.RaiseManagerError(pPara^.aPara[0]$UDINT);
      end_if;
  
  END_CASE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL HwControl::CyWork
  VAR_INPUT
    EAX 	: UDINT;
  END_VAR
  VAR_OUTPUT
    state (EAX) 	: UDINT;
  END_VAR
  VAR
    pHelp : ^t_HwObjectListElement;
  END_VAR

  // objects, which are controlled by HwControl
  if pHwControlLogins then
    pHelp := pHwControlLogins;
    while pHelp <> NIL do
      if pHelp^.bdSettings.Cyclic then
        pHelp^.pThis^.CyWork(0);
      end_if;

      pHelp := pHelp^.pNext;
    end_while;
  end_if;

  state := READY;

END_FUNCTION


FUNCTION GLOBAL HwControl::AddHwObject
	VAR_INPUT
		pThis 	: pVirtualBase;
		Settings 	: t_HwObjListSettings;
		EscapeSequence 	: USINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    pHelp : ^t_HwObjectListElement;
  END_VAR

  if pHwControlLogins = NIL then
    pHwControlLogins$pVoid := To_StdLib.Malloc(size:=sizeof(t_HwObjectListElement));
    pHelp := pHwControlLogins;
  else
    pHelp := pHwControlLogins;
    while (pHelp^.pThis <> pThis) & (pHelp^.pNext <> NIL) do
      pHelp := pHelp^.pNext;
    end_while;
    if (pHelp^.pThis <> pThis) then
      pHelp^.pNext$pVoid := To_StdLib.Malloc(size:=sizeof(t_HwObjectListElement));
      pHelp := pHelp^.pNext;
//  else
//    already in list and pHelp points to it to update the settings
    end_if;
  end_if;
  
  if pHelp <> NIL then
    pHelp^.pThis := pThis;
    pHelp^.pRtPostScan := NIL;
    pHelp^.bdSettings := Settings;
    pHelp^.usEscSequence := EscapeSequence;
    pHelp^.pNext   := NIL;
    retcode := 0;
  else
    retcode := -1;
  end_if;

END_FUNCTION


FUNCTION HwControl::InstallPostInitCB
  VAR_OUTPUT
    sd_retval 	: DINT;
  END_VAR
  VAR
    pFunction : ^void;
  END_VAR
  
  sd_retval := -1;

  if b_PostInitInstalled = TRUE then
    sd_retval := 0;   // Return OK
  else
  
    // tell the loader that we need a post init phase
    pFunction := _FindFctName("LDR_InstallPostInitCB");
    if ( pFunction <> NIL ) then
      pFunction $ LDR_InstallPostInitCB(pThis:=this, pCmdSvr:=(#this^.Control.pMeth)$^SvrChCmd, newInstCmd:=CMD_POST_INIT_CALL);
      
      b_PostInitInstalled := TRUE;
      sd_retval := 0;
      
    end_if;
  end_if;
  
END_FUNCTION
